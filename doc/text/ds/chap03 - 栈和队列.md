# 栈和队列

线性表是一个非常“开放的”数据结构，您可以访问、插入和删除线性表上的任何一个数据单元。但在实际的计算模型中，并不是所有的数据结构都允许您这样做。

本章介绍的**栈**（stack）、**队列**（queue）以及**双端队列**（deque）就是典型的“访问受限制”的数据结构，它们的实现都是以线性表作为基础的。另一种经典的限制访问的数据结构是**优先队列**（priority queue），它需要以树作为基础，因此本章暂时不讨论它。

栈和队列限制了用户访问元素的范围，这使得它们能够防止用户做出对进程、系统、计算机或网络有害的“非法”行为，在《操作系统》和《网络原理》中都能看到它们的应用。

## 栈

**栈**（stack）是一种特殊的线性表。对于栈`S[0:n]`，它的访问、插入、删除操作均只能对**栈顶元素**（top或peek，即栈的最后一个元素）`S[n-1]`进行。

* 栈的访问就是取`S[n-1]`。

* 栈的插入就是在`S[n-1]`后面插入新的元素（称为**入栈**或**推入**，push）。

* 栈的删除就是将`S[n-1]`从栈中删除（称为**出栈**或**弹出**，pop）。

  由于弹出后的元素往往另有他用，`pop`操作会将被删除的栈顶元素返回。

### 用向量实现栈

由于栈实质上是对线性表的访问权限作出限定，所以很容易在向量的基础上建立栈。

```c++
template <typename T>
class Stack : protected Vector<T> { // 利用protected继承做访问限制
public:
    T top() const { return data()[size()-1]; }
    void push(T e) { push_back(e); }
    T pop() { return pop_back(); }
};
```

> 其中`push_back`和`pop_back`分别表示在向量的末尾插入或删除元素，这一过程可能会引发向量的扩容和缩容。
>
> 为了效率，笔者不考虑鲁棒性问题：对空栈使用`top`和`pop`会引发错误。

显然取顶的时间复杂度是$O(1)$，入栈和出栈的时间复杂度在分摊意义下也是$O(1)$。

栈的操作到这里就介绍完了。

### 栈的性质：后进先出

因为栈只能从尾部进行操作的特性，栈有可能被写作`[ S0, S1, S2, ..., Sn-1 >`的形式，左侧的中括号表示不可操作的一端（**盲端**），右侧的尖括号表示可操作的一端（**自由端**）。更常见的一种表示方法是把它竖过来：

![栈](..\..\pic\ds\栈.png)

如图所示，可以把栈想成一个桶，盲端是桶的底部，自由端（栈顶）是桶中最上面的物品。于是，`push`操作就是往桶里放东西，后放的东西总是放在先放的东西的上面，像上图中，B放在A上面，C放在B上面。而要取东西（`pop`）的时候，每次只能取桶里最上面的东西，也就是栈顶元素。在上图里，为了把B取出来，必须先把B上面的C取出来。

就像列表相关问题经常用链式图帮助思考一样，处理和分析栈的相关问题经常要用到上面这种桶式图。

从上图中不难发现，栈的最重要的性质是：<u>先入栈的元素后出栈，后入栈的元素先出栈</u>，简称为“**后进先出**”（**LIFO**, Last In First Out）。生活中有不少LIFO的例子，比如，桌子上一大摞书需要先搬开上面的才能拿下面的，这些现象被抽象化到计算机中处理就对应栈这种数据结构。

和栈相关的题目，通常有两个命题方向：

1. 考察对栈性质（也就是LIFO）的理解。
2. 在访问受限的情况下设计算法。这个比较少见。

在下面的几节，将介绍栈的几个应用以加深您对栈性质的理解。这些应用本身也是重要的考点，栈的大多数题目都出自这些应用。

### 出栈序列

### Catalan数

### 尾递归消除

### 后缀表达式

### 后缀表达式的计算

### 中缀表达式的计算

## 队列

### 队列的性质：先进先出

### 用向量实现队列

### 循环队列

### 用列表实现队列









