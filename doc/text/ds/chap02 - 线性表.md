# 线性表

**线性表**是指相同类型的有限个数据组成的序列。在这本笔记中采用的是清华大学教材的分法，将线性表包括**向量**（vector）和**列表**（list）两种形式，分别对应C++ STL里的`vector`和`list`。

> 在另一些教材中，这两个词被称为**顺序表**和**链表**，分别对应Java里的`ArrayList`和`LinkedList`。向量（顺序表）和列表（链表）这两对概念通常可以混用。

向量和列表代表着两种最基本的数据结构组织形式：**顺序结构**和**链式结构**。本章在分别介绍这两种数据结构之后，将会进一步介绍这两种结构级联得到的**分块结构**。

## 向量

> 中国革命必须分为两个步骤。第一步，改变这个殖民地、半殖民地、半封建的社会形态，使之变成一个独立的民主主义的社会。第二步，使革命向前发展，建立一个社会主义的社会。
>
> ——Chairman Mao

**向量**（vector）是一个基于**数组**（array）的数据结构，因此向量在内存中占据的是一段连续的空间。

### 向量和数组

**元素**（element）代表数据结构中的单个数据单元，它可能是基本数据类型、结构体、函数等。一个数据结构中的元素具有统一的类型。所有数据结构都是由元素构成的。

**线性表**是元素成线性排列的表。作为一种基于数组的线性表，<u>向量的元素次序和数组的元素次序相同</u>。如果一个向量`V`基于数组`A[0:m]`构建，那么向量`V`的第`i`个元素就是`A[i]`。

> 说向量元素的**物理次序**和**逻辑次序**相同是不妥的，尽管这种说法可能能帮助您理解向量，但可能会引起新的混乱。
>
> 在《计算机组成原理》和《操作系统》学科中您将会看到，<u>“物理”和“逻辑”这两个相对的名词一般用于**实际内存**和**虚拟内存**的场合</u>。数组在虚拟内存上的逻辑地址总是连续的，但在实际内存上的物理地址受操作系统调度影响，可能由多个不连续的部分组成。所以用“物理次序”这样一个有歧义的名词是不妥的。

需要注意的是，尽管向量和它基于的数组在<u>元素次序上相同</u>，但在<u>元素数量上是不一定相同</u>的。数组的元素数量总是恒定的，而向量的元素数量是<u>运行时可变的</u>。

记一个长度为`n`的向量为`V[0:n] = { V[0], V[1], ..., V[n-1] }`，则`n`称为向量`V`的**规模**（size），而称为向量`V`分配的内存空间可以容纳的元素数量`m`（即它所基于的数组的规模）为向量`V`的**容量**（capacity）。

> 一个向量的<u>规模必定不大于容量</u>。在不超过容量的前提下，向量的规模可以灵活变化，从而赋予了它比数组更高的灵活性。

对于向量中的每一个元素`V[i]`来说，它前面的元素称为它的**前驱**（predecessor），它后面的元素称为它的**后继**（successor），特别地，和它位置相邻的前驱，也就是**直接前驱**为`V[i-1]`，相应地，**直接后继**为`V[i+1]`。所有的前驱构成了**前缀**（prefix），也就是`V[0:i]`；所有的后继构成了**后缀**（suffix），也就是`V[i+1:n]`。

### 循秩访问

在本笔记中介绍的各种数据结构，将从一个非常小的基础模板开始逐步添加功能。您可以跟随笔记的正文自己实现模板，或参考配套代码中的模板。

> 为了让模板更有用，配套代码里还实现了一些和《数据结构》知识关系不大的函数。这些内容在笔记正文中不会介绍。

在上一小节中已经介绍过向量的基本元素：用于存放数据的数组，以及规模、容量两个基本属性。据此，可以写出一个基本的框架如下。

```c++
template <typename T>
class Vector {
    T* _data;      // 向量所基于的数组
    int _capacity; // 向量的容量
    int _size;     // 向量的规模
public:
    int capacity() { return _capacity; }
    int size() { return _size; }
};
```

> 这里将规模和容量都定义成了**私有**（private）变量，并提供了公共的`getter`方法。因为向量外的代码不应该直接修改它们。

对于向量中的元素，其访问方式称为**循秩访问**。称元素`V[i]`在向量`V`中的序号，也就是`i`，为它的**秩**（rank）。对于建立在数组`A`上的向量`V`，因为`V`和`A`的元素次序是一致的，所以`V[i] = A[i] = *(A+i)`。因此，只要知道一个元素的秩，就可以在$O(1)$的时间内访问该元素。

```c++
T& operator[](int index) {
    return _data[index];
}
```

> 如果`index`超出了`capacity`，会发生数组越界，可能引起**段错误**（segmentation fault）。如果追求稳健性，应当增加一个`index < capacity`的判断。但为效率起见，这里舍弃了这一判断。
>
> 后文中同样会舍弃一些稳健性的考量。

### 装填因子

设向量的容量为`m`，规模为`n`，则称比值`n/m`为**装填因子**（load factor）。正常情况下，这是一个`[0,1]`之间的数。装填因子是衡量向量效率的重要指标。

<u>如果装填因子过小</u>，则会造成内存浪费：申请了巨大的数组，但其中只有少量的单元被向量中的元素用到，其他单元都被闲置了。

<u>如果装填因子过大</u>（超过1），则会引发数组越界，造成段错误。

> 刚开始的时候，装填因子一定是在`[0,1]`之间的。
>
> 但因为数组的容量`m`是固定的，而向量的规模`n`是动态的，所以一开始分配的`m`可能后来会不够用，从而产生装填因子大于1的问题。

为了让装填因子保持在一个合理的范围，需要允许动态地改变容量`m`的值。令m增大的操作称为**扩容**，令m减小的操作称为**缩容**。

### 改变向量的容量

首先来看向量扩容。

```c++
// 问题2.1 - 向量扩容
// 分析合适的方式让向量扩容
```

这就不是上一章那种简单的算法问题了，需要逐步分析。

首先，直接在原向量所占空间后面增加“一条尾巴”是不现实的，因为原向量所占空间后面的地址，可能已经被分配给了其他变量。因此，合适的做法是<u>重新建立一个更大的数组，将原向量的数据复制到新数组中，再把原数组的空间释放掉</u>。

> 注意这个操作对于缩容也是一样的，只是缩容是建立了一个更小的数组。

```c++
// 算法2.1A
template <typename T>
void Vector<T>::set_capacity(int new_capacity) {
    T* old = _data;
    _data = new T[_capacity = new_capacity];
    arrayCopy(_data, old, _size);
    delete[] old;
}
```

> 这里`arrayCopy(T* dst, T* src, int size)`函数用来将大小为`size`的数组从`src`移动到`dst`位置。

设`new_capacity`为`M`，则上述**算法2.1A**的时间和空间复杂度均为$O(M)$。

### 等差扩容和等比扩容

**算法2.1A**仍然没有解决关键问题：在实际使用中，用户不一定知道应该扩容到多少：如果新的容量`M`比较小，就可能再次发生数组越界，就需要再次调用`set_capacity`函数扩容，<u>消耗时间</u>；如果`M`比较大，则装填因子太低，<u>浪费空间</u>。

<u>所以，向量的设计者应该提供一个合理的扩容规则</u>。如果用户知道怎么扩容当然最好，但当用户不知道应该扩容到多少的时候，这个<u>合理的扩容规则</u>给了他们一个备选项。只要选择按照向量设计者提供的规则来扩容，使得时间和空间效率都不会太低。

那么应该如何设计扩容规则呢？

第一种方法是按照等差数列扩容，规定一个公差`d`，每次扩容都让容量`+d`（**固定扩容**），也就是从`m`变成`m+d`；第二种方法是按照等比数列扩容，规定一个公比`q`，每次扩容都让容量`*q`（**比例扩容**），也就是从`m`变成`qm`。

