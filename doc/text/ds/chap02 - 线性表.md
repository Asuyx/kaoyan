# 线性表

**线性表**是指相同类型的有限个数据组成的序列。在这本笔记中采用的是清华大学教材的分法，将线性表包括**向量**（vector）和**列表**（list）两种形式，分别对应C++ STL里的`vector`和`list`。

> 在另一些教材中，这两个词被称为**顺序表**和**链表**，分别对应Java里的`ArrayList`和`LinkedList`。向量（顺序表）和列表（链表）这两对概念通常可以混用。

向量和列表代表着两种最基本的数据结构组织形式：**顺序结构**和**链式结构**。本章在分别介绍这两种数据结构之后，将会进一步介绍这两种结构级联得到的**分块结构**。

## 向量

> 中国革命必须分为两个步骤。第一步，改变这个殖民地、半殖民地、半封建的社会形态，使之变成一个独立的民主主义的社会。第二步，使革命向前发展，建立一个社会主义的社会。
>
> ——Chairman Mao

**向量**（vector）是一个基于**数组**（array）的数据结构，因此向量在内存中占据的是一段连续的空间。

### 向量和数组

**元素**（element）代表数据结构中的单个数据单元，它可能是基本数据类型、结构体、函数等。一个数据结构中的元素具有统一的类型。所有数据结构都是由元素构成的。

**线性表**是元素成线性排列的表。作为一种基于数组的线性表，<u>向量的元素次序和数组的元素次序相同</u>。如果一个向量`V`基于数组`A[0:m]`构建，那么向量`V`的第`i`个元素就是`A[i]`。

> 说向量元素的**物理次序**和**逻辑次序**相同是不妥的，尽管这种说法可能能帮助您理解向量，但可能会引起新的混乱。
>
> 在《计算机组成原理》和《操作系统》学科中您将会看到，<u>“物理”和“逻辑”这两个相对的名词一般用于**实际内存**和**虚拟内存**的场合</u>。数组在虚拟内存上的逻辑地址总是连续的，但在实际内存上的物理地址受操作系统调度影响，可能由多个不连续的部分组成。所以用“物理次序”这样一个有歧义的名词是不妥的。

需要注意的是，尽管向量和它基于的数组在<u>元素次序上相同</u>，但在<u>元素数量上是不一定相同</u>的。数组的元素数量总是恒定的，而向量的元素数量是<u>运行时可变的</u>。

记一个长度为`n`的向量为`V[0:n] = { V[0], V[1], ..., V[n-1] }`，则`n`称为向量`V`的**规模**（size），而称为向量`V`分配的内存空间可以容纳的元素数量`m`（即它所基于的数组的规模）为向量`V`的**容量**（capacity）。

> 一个向量的<u>规模必定不大于容量</u>。在不超过容量的前提下，向量的规模可以灵活变化，从而赋予了它比数组更高的灵活性。

对于向量中的每一个元素`V[i]`来说，它前面的元素称为它的**前驱**（predecessor），它后面的元素称为它的**后继**（successor），特别地，和它位置相邻的前驱，也就是**直接前驱**为`V[i-1]`，相应地，**直接后继**为`V[i+1]`。所有的前驱构成了**前缀**（prefix），也就是`V[0:i]`；所有的后继构成了**后缀**（suffix），也就是`V[i+1:n]`。

### 循秩访问

在本笔记中介绍的各种数据结构，将从一个非常小的基础模板开始逐步添加功能。您可以跟随笔记的正文自己实现模板，或参考配套代码中的模板。

> 为了让模板更有用，配套代码里还实现了一些和《数据结构》知识关系不大的函数。这些内容在笔记正文中不会介绍。

在上一小节中已经介绍过向量的基本元素：用于存放数据的数组，以及规模、容量两个基本属性。据此，可以写出一个基本的框架如下。

```c++
template <typename T>
class Vector {
    T* _data;      // 向量所基于的数组
    int _capacity; // 向量的容量
    int _size;     // 向量的规模
public:
    int capacity() { return _capacity; }
    int size() { return _size; }
};
```

> 这里将规模和容量都定义成了**私有**（private）变量，并提供了公共的`getter`方法。因为向量外的代码不应该直接修改它们。

对于向量中的元素，其访问方式称为**循秩访问**。称元素`V[i]`在向量`V`中的序号，也就是`i`，为它的**秩**（rank）。对于建立在数组`A`上的向量`V`，因为`V`和`A`的元素次序是一致的，所以`V[i] = A[i] = *(A+i)`。因此，只要知道一个元素的秩，就可以在$O(1)$的时间内访问该元素。

```c++
T& operator[](int index) {
    return _data[index];
}
```

> 如果`index`超出了`capacity`，会发生数组越界，可能引起**段错误**（segmentation fault）。如果追求稳健性，应当增加一个`index < capacity`的判断。但为效率起见，这里舍弃了这一判断。
>
> 后文中同样会舍弃一些稳健性的考量。

### 装填因子

设向量的容量为`m`，规模为`n`，则称比值`n/m`为**装填因子**（load factor）。正常情况下，这是一个`[0,1]`之间的数。装填因子是衡量向量效率的重要指标。

<u>如果装填因子过小</u>，则会造成内存浪费：申请了巨大的数组，但其中只有少量的单元被向量中的元素用到，其他单元都被闲置了。

<u>如果装填因子过大</u>（超过1），则会引发数组越界，造成段错误。

> 刚开始的时候，装填因子一定是在`[0,1]`之间的。
>
> 但因为数组的容量`m`是固定的，而向量的规模`n`是动态的，所以一开始分配的`m`可能后来会不够用，从而产生装填因子大于1的问题。

为了让装填因子保持在一个合理的范围，需要允许动态地改变容量`m`的值。令m增大的操作称为**扩容**，令m减小的操作称为**缩容**。

### 改变向量的容量

首先来看向量扩容。

```c++
// 问题2.1 - 向量扩容
// 分析合适的方式让向量扩容
```

这就不是上一章那种简单的算法问题了，需要逐步分析。

首先，直接在原向量所占空间后面增加“一条尾巴”是不现实的，因为原向量所占空间后面的地址，可能已经被分配给了其他变量。因此，合适的做法是<u>重新建立一个更大的数组，将原向量的数据复制到新数组中，再把原数组的空间释放掉</u>。

> 注意这个操作对于缩容也是一样的，只是缩容是建立了一个更小的数组。

```c++
// 算法2.1A
template <typename T>
void Vector<T>::set_capacity(int new_capacity) {
    T* old = _data;
    _data = new T[_capacity = new_capacity];
    arrayCopy(_data, old, _size);
    delete[] old;
}
```

> 这里`arrayCopy(T* dst, T* src, int size)`函数用来将大小为`size`的数组从`src`移动到`dst`位置。

设`new_capacity`为`M`，则上述**算法2.1A**的时间和空间复杂度均为$O(M)$。

### 等差扩容和等比扩容

**算法2.1A**仍然没有解决关键问题：在实际使用中，用户不一定知道应该扩容到多少：如果新的容量`M`比较小，就可能再次发生数组越界，就需要再次调用`set_capacity`函数扩容，<u>消耗时间</u>；如果`M`比较大，则装填因子太低，<u>浪费空间</u>。

<u>所以，向量的设计者应该提供一个合理的扩容规则</u>。如果用户知道怎么扩容当然最好，但当用户不知道应该扩容到多少的时候，这个<u>合理的扩容规则</u>给了他们一个备选项。只要选择按照向量设计者提供的规则来扩容，使得时间和空间效率都不会太低。

那么应该如何设计扩容规则呢？

第一种方法是<u>按照等差数列扩容</u>，规定一个公差`d`，每次扩容都让容量`+d`（**固定扩容**），也就是从`m`变成`m+d`；第二种方法是<u>按照等比数列扩容</u>，规定一个公比`q`，每次扩容都让容量`*q`（**比例扩容**），也就是从`m`变成`qm`。

```c++
// 算法2.1B - 基本框架
template <typename T>
void Vector<T>::expand(function<int(int)> strategy) {
    set_capacity(strategy(_capacity));
}

// 算法2.1B1 - 固定扩容
template<typename T>
void expandByAP(const Vector<T>& V, int d) {
    V.expand([=](int m) -> { return m + d; });
}

// 算法2.1B2 - 比例扩容
template<typename T>
void expandByGP(const Vector<T>& V, double q) {
    V.expand([=](int m) -> { return (int)(m * q); });
}
```

> 这里允许**比例因子**`q`不是整数。实际使用时，如果比例因子是整数，则应当声明`q`为`int`类型以加快运算速度。特别地，如果`q`是2的幂次，可以写成移位计算的形式进一步加快运算速度。

很显然，在`strategy`函数只进行了简单的加（或乘）运算的情况下，`expand`只进行了一次`set_capacity`的操作，其效率和单次的`set_capacity`基本一致。

那么，<u>固定扩容和比例扩容</u>这两种扩容方式哪种更好？它们都只调用了一次`expand`，所以它们的效率是一样的吗？

显然不是的。设计**算法2.1B1**和**算法2.1B2**的原理，是按照等差或等比“<u>*数列*</u>”扩容，而不是“<u>*一次*</u>”扩容。所以评价这两种扩容规则的标准，不是<u>进行一次扩容</u>的效率或<u>进行一次扩容</u>后的装填因子，而是比较<u>一系列扩容</u>操作的总体效率和在这<u>一系列扩容</u>操作中的平均装填因子。用已有的复杂度分析工具不足以对这两种策略的效率进行准确评价。

### 分摊复杂度分析

为了对**一系列操作**进行分析，需要引入新的复杂度分析标准。

一般地，假设$O_1, O_2, \dots, O_n$是连续进行的`n`次操作，则当$n\to\infty$，这`n`次<u>连续操作所用时间的平均值的复杂度</u>，称为这一操作的**分摊复杂度**，对分摊复杂度的分析称为**分摊分析**。分摊分析的原则之一是：<u>使用相同效果的操作序列</u>。所以，要比较**算法2.1B1**和**算法2.1B2**，不应该把每次操作取为"进行一次扩容"（因为两种方法扩容量不一样)，而应该取为“向量`V`的规模增加`1`”。连续进行`n`次操作，就可以考虑向量`V`的规模从`0`增长为`n`的过程。

**算法2.1B1**中，容量依次被扩充为$d,2d,3d,\dots,n$，共进行$n/d$次扩容。

因此，分摊复杂度为：
$$
T(n) = \frac{d + 2d + 3d + \dots + n}n = \frac{(n/d)\cdot d + (n/d)(n/d-1)/2\cdot d}n = \frac{n/d+1}2 = O\left(\frac nd\right)
$$
另一方面，进行k次扩容之后的装填因子至少为$\frac{kd}{(k+1)d}=\frac{k}{k+1}$，当$k\to\infty$时，装填因子趋于**100%**。

**算法2.1B2**中，容量被依次扩充为$q,q^2,q^3,\dots,n$，共进行$\log _q n$次扩容。

因此，分摊复杂度为：
$$
T(n)=\frac{q+q^2+q^3+\dots+n}n=\frac{q\cdot\frac{1-n}{1-q}}n=O(1)
$$
另一方面，装填因子不断在$[\frac 1q,1]$之间线性增长，平均装填因子为$\frac{1+q}{2q}$。可以看出，不管怎样选择`q`，对分摊复杂度都没有影响，而更小的`q`能够带来更大的平均装填因子。因此，在实际的向量扩容过程中，总是选择`q = 2`，这时平均装填因子为**75%**。

从上面的分摊分析中可以看出，**算法2.1B1**尽管能够带来更高的装填因子，但时间效率略有不足；而**算法2.1B2**则在保证装填因子不太低的情况下，时间效率非常优秀。

所以，通常向量扩容会选择**算法2.1B2**的规则。

> 不过，**算法2.1B2**也有其劣势，就是容量越大，装填因子不高带来的空间浪费愈发明显，所以有些对空间要求较高的情况下，也采用二者相结合的方式：<u>在容量比较小时加倍扩容、在容量比较大的时候固定扩容</u>，在《计算机网络原理》的学习中您将看到二者相结合的例子。

### 缩容

介绍完扩容，缩容的方法也呼之欲出了：无非是**固定缩容**或者**减半缩容**。您可以自己完成这两个算法。

缩容的重要性远不如扩容，因为缩容降低`m`之后，如果`n`又扩大回去了，就又要扩容回去，这一缩一扩浪费了不少时间，而发挥的价值甚微（除非在这段缩、扩之间的时间里，释放出的内存另有他用）。为了避免一缩一扩浪费时间，通常会规定一个**缩容阈值**，当装填因子小于这个阈值的时候才会缩容。

对于常用的<u>比例扩容+比例缩容</u>的策略，您可以自己证明，只要<u>缩容阈值<50%</u>，就可以保证对于任意的操作序列（每个操作是`n`加一或减一），扩容和缩容的<u>综合分摊复杂度</u>为$O(1)$。在实际的向量中，为了方便计算，缩容阈值通常使用25%、12.5%等数值，取为0（**禁止缩容**）也是一个常见的策略。

### 插入单个元素

对于任何数据结构，都有三种基本的操作：

* **插入**（insert）：向数据结构中插入一个元素。

* **查找**（find）：查找一个元素在数据结构中的位置。

  > 进一步地，可以研究如何查找<u>满足特定条件的元素</u>在数据结构中的位置。

* **删除**（delete）：从数据结构中移除一个元素。

  因为移除一个元素往往需要定位它所在的位置，所以通常删除操作包含了至少1次查找操作。

  > 因为`delete`是许多语言的关键字，所以在编程的时候常用`remove`代替它。

下面就以向量为例，分别介绍这三种基本的操作。

```c++
// 问题2.2 - 向量插入元素
// 给定：向量V[0:n]
// 输入：待插入的元素e，目标的秩r
// 要求：将元素e插入到V[r]的位置上
```

首先讨论插入。

要将待插入的元素`e`插入到`V[r]`，那么可以将原来的向量`V[0:n]`分成`V[0:r]`和`V[r:n]`两部分。

* 插入之前，向量是`V[0:r]`，`V[r:n]`。
* 插入之后，向量是`V[0:r]`，`e`，`V[r:n]`。

可以发现，在插入的前后，前一段`V[0:r]`的位置是不变的，而后一段`V[r:n]`需要整体向后移动1个单元的位置。据此，可以设计下面的算法。

```c++
// 算法2.2A
template <typename T>
void Vector<T>::insert(T e, Rank r) {
    if (_size + 1 > _capacity) { expand(); }    // 插入后会超出容量，需要扩容，此处省略扩容策略
    arrayCopy(_data+r+1, _data+r, _size-r, -1); // 从后向前，依次移动V[r:n]中的每个元素
    _data[r] = e;
    ++_size; // 更新向量的规模
}
```

> `arrayCopy`那行语句从功能上等价于`V[r+1:n+1] = V[r:n]`，就是将`V[r:n]`整体后移1个单元。
>
> 这里`arrayCopy`的最后一个参数表示从后向前更新（您可以自己想一下，如果从前向后更新会发生什么？）。`arrayCopy`的实现见配套代码。

不考虑扩容（前面已经证明，扩容的分摊复杂度是$O(1)$，它不会影响到其他操作的复杂度），则单次插入的时间复杂度为$\Theta(n-r)$，空间复杂度$O(1)$。

### 平均复杂度分析

为了更定量地分析插入操作的时间效率，引入一个新的复杂度分析策略：**平均复杂度**。

在介绍复杂度时曾经强调，复杂度是依赖于<u>数据规模</u>，不依赖于<u>具体情况</u>的分析手段。在**算法2.2A**中，数据规模通常认为是`n`，而`r`是具体情况带来的参数。为了研究不同具体情况对算法时间效率的影响，有三种常见的分析手段：

* **最坏时间复杂度**：研究在情况最坏的情况下的复杂度。

  很多算法有硬性的时间限制（如<u>在复试的机试中，通常要求输出结果的时间不能多于1s或2s</u>），此时常常使用最坏时间复杂度分析。这是最常用的时间复杂度分析。

* **最好时间复杂度**：研究在情况最好的情况下的复杂度。

  研究最好时间复杂度的意义远小于最坏时间复杂度。最好时间复杂度往往用于嘲讽某种算法的效率：在最好的情况下，这种算法的复杂度也只能达到XXXX，而我的新算法可以达到XXXX。

* **平均时间复杂度**：研究在平均情况下的复杂度。

  如果没有硬性的时间限制，则平均时间复杂度往往能更好地反映一个算法的总体时间效率。

  平均时间复杂度需要知道<u>各种情况的**先验**概率</u>，在这个概率的基础上计算$T(n)$的**数学期望**的复杂度。在针对显示数据的实验研究中，常见的假设包括正态分布、gamma分布和Poisson分布；而在《数据结构》学科中，通常假设成<u>等可能的分布</u>，以方便进行理论计算。

  > 分摊复杂度是一系列连续操作的平均效率，而平均复杂度是单次操作的期望效率。
  >
  > 分摊复杂度的一系列连续操作是有可能存在后效的，而平均复杂度只讨论单次操作的可能情况。
  >
  > 分摊复杂度需要指定每次进行何种的**基本操作**，而平均复杂度需要指定各种情况的**先验概率**。
  >
  > 这两个概念务必加以区分。

现在回到插入的**算法2.2A**，它的时间复杂度是$\Theta(n-r)$。显然，最好时间复杂度是$O(1)$（插入在末尾的情况），最坏时间复杂度是$\Theta(n)$（插入在开头的情况）。

为了求平均时间复杂度，一个合理的假设是，`r`的取值对于`[0:n]`之间的整数是等概率的。在这个假设下，容易算出单次插入的<u>平均时间复杂度</u>为$\Theta(n)$。

### 插入批量元素

如果要插入的不是单个元素，而是多个元素，情况会发生什么变化呢？

```c++
// 问题2.3 - 向量插入多个元素（向量合并）
// 给定：向量V[0:n]
// 输入：待插入的向量V1[0:n1]，目标的秩r
// 要求：将向量V1整体插入到V中，其中V1[0]插入到V[r]的位置上
```

在**问题2.3**中，需要插入`n1`个连续的元素。最简单的想法是直接调用`n1`次**算法2.2A**，然而这样的总时间复杂度高达平均$\Theta(n\cdot n_1)$，略显笨重。

您可以敏锐地发现，只要再次使用在讨论单元素插入时的分析方法，就可以得到更加高效的算法。

要将待插入的向量`V1`插入到`V[r]`，那么可以将原来的向量`V[0:n]`分成`V[0:r]`和`V[r:n]`两部分。

* 插入之前，向量是`V[0:r]`，`V[r:n]`。
* 插入之后，向量是`V[0:r]`，`V1`，`V[r:n]`。其中，`V[r:n]`被转移到了`V[r+n1:n+n1]`的位置上。

```c++
// 算法2.3A - 向量插入元素（批量）
template <typename T>
void Vector<T>::insert(const Vector<T>& V, Rank r) {
    int new_size = _size + V._size;                   // 计算插入之后的向量规模
    if (new_size > _capacity) { expand([=](int m) -> int {
        return max(new_size, capacity_expand_strategy(m));
    }); }        // 插入后会超出容量，需要扩容。这里省略指定的capacity_expand_strategy
    arrayCopy(_data+r+V._size, _data+r, _size-r, -1); // 从后向前，依次移动V[r:n]中的每个元素
    arrayCopy(_data+r, V._data, V._size);             // 依次插入V1中的元素
    _size = new_size; // 更新向量的规模
}
```

**算法2.3A**的平均时间复杂度为$\Theta(n+n_1)$，比连续调用`n1`次**算法2.2A**要优秀得多。**算法2.3A**中体现出的“<u>用块操作代替多次单元操作</u>”的思想，在以线性表为背景的算法设计题中应用广泛。

> **算法2.3A**仍然有继续改进的空间。
>
> 在**算法2.3A**的实现中，<u>插入操作和扩容操作</u>是解耦的。事实上，在扩容申请了新的数组空间之后，没有必要先把原数组的元素复制过去再移动。移动可以复制到新数组空间的同时进行，从而减少一次`arrayCopy`移动的时间。您可以自己实现这个改进版本的算法。

### 删除元素

删除元素是插入元素的逆操作。在插入元素时，让<u>被插入元素的后继后移</u>；因此在删除元素的时候，只需要让<u>被删除元素的后继前移</u>即可。

