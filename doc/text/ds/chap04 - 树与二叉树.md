# 树与二叉树

在前两章中介绍的向量、列表、栈、队列、双端队列都属于**线性结构**，元素之间存在一个线性的次序。分块表属于**块状结构**，但块和块之间、块内部各个元素之间，仍然是线性的，所以也可以被归入**线性结构**的范畴。

这一章将介绍的**树**（tree）则是一种**半线性结构**。

> 一方面，树不是完全的线性结构，因为不是任意两个元素都有次序；
>
> 另一方面，树也不是完全的非线性结构，因为也不是任意两个元素，都不能比较次序，并且在规定了一定的约束条件的前提下，它可以转化成一个有线性次序的序列。

有关树的内容是整个《数据结构》学科的核心，也是考试的重点和难点所在。同时，在这一部分，清华大学的本科教学无论是知识点的数量，还是知识点的深度，都超出了统考大纲很多。

因此，笔者将半线性结构的内容拆分成了三章。本章介绍树和二叉树的基本概念，下一章介绍二叉搜索树，最后介绍优先队列；跳表和k-d树则被安排到了后面的《查找》一章。在《算法设计》部分，将介绍初试之外、机试可能涉及的一些树的应用。

<u>特别注明：本笔记的内容确认和邓俊辉《数据结构》的定义没有冲突，但不确认和其他的教材没有冲突。在树的部分，存在很多定义有争议的内容，请您根据您使用的教材进行甄别。</u>

## 树与二叉树的结构

这一节从数学上的树出发，逐步增加限制条件，为您展示计算机领域研究的树有何特性。

在这一节里介绍的内容是纯理论的，并不包含算法和实际的代码实现，其目的在于让您对计算机领域所研究的树有一个清楚的理解。如果您已经非常熟悉树有关的理论知识，也可以选择跳过这一节。

### 树的定义

一棵树由被称为**顶点**（vertex）的数据单元，和若干连接不同顶点的**边**（edge）组成。在计算机领域，讨论树的时候顶点通常称为**节点**或**结点**（node），就和前面介绍的列表一样。

> 计算机领域的树和数学上的树有一定的不同，在这一节将具体介绍。采用顶点还是节点的叫法，一定程度上有助于区分上下文提到的树，是指计算机领域的树，还是数学上的树。

在数学上，**树**（tree）被定义为连通无环图。您可以通过一个具体的例子理解什么是树：

![树](../../pic/ds/树.png)

在上图中，左边的黄色部分是一棵树；中间的蓝色部分因为多了一条粉色边，形成了ABCF的环，所以不是一棵树；右边的绿色部分因为少了一条边，导致D和其他顶点不连通，所以也不是一棵树。

> 一般的无环图称为**森林**（forest），森林可以看成是一棵或多棵树组成的，它不需要满足连通性。

类似前面介绍过的数据结构，将树中顶点的数量称为树的**规模**（size）。计算机领域研究的树，规模总是有限值，因此称为**有限树**。

规模为0（没有顶点也没有边）的树称为**空树**。空树和规模为1（只有1个顶点，没有边）的树合称为**平凡树**，这2种特殊情形在分析树的相关性质时经常需要单独拿出来讨论，比如作为递归边界等。

### 树的基本性质

**命题1. 树的任意两个顶点之间，有且只有1条路可以连通。**

> “有1条”由树的连通性保证。
>
> “只有1条”由树的无环性保证。

在树上，只被1条边连接的点称为**叶子**。

**命题2. 非平凡树上至少有2个叶子。**

> 设`(A, B)`是树上不经过重复顶点的最长路。
>
> > 一条路径的**长度**，等于其经过的边数。
>
> 假设`A`被不在`(A, B)`路径上的边`(A, X)`连接，那么如果`X`是`(A, B)`经过的顶点，树上就有了环，矛盾；如果`X`不是`(A, B)`经过的顶点，`(X, B)`就是一条更长的路，和`(A, B)`最长性矛盾。
>
> 因此，`A`只被1条边连接，也就是`(A, B)`路径经过的那条边。同理，`B`也只被1条边连接。因此，树上至少有2片叶子。

记树的规模为`n`，树上的边数为`m`。

**命题3. 当n > 0时，m = n - 1。**

> 递归边界是`n=1`，此时恰好有`0`条边。
>
> 对于`n>1`，由于树上至少存在一个叶子`A`，将`A`以及连接`A`的那条边从树上删去，得到的就是一棵规模`n-1`的树。递归下去即可证明规模为`n`（`n>0`）的树上恰好`n-1`条边。

上述的两个命题用到了两个重要的技巧。

1. 最值反证法。通过取一个“最大”或“最小”的情况（树的规模有限，因此最值一定存在），让反证法的假设和最值矛盾。这种方法通常用于<u>数学性质的证明</u>，因此在考试中出现的频率比较低。
2. 递降法。这个方法在前面已经多次使用，在计算机领域，这种方法的使用频率会比反证法高得多；并且，<u>因为在计算机领域的树是**递归定义的**，所以它天然具有应用递降法的背景条件</u>，在下一小节将会展开介绍这一点。

下面两个对称的命题，证明非常简单，不再赘述。

**命题4. 在树上删除任何一条边，都会破坏连通性。**

**命题5. 在树上添加任何一条边，都会破坏无环性。**

### 有根树

回到树的问题上来。上述定义的数学上的树，是不具有半线性性质的。为了让其有半线性性质，需要规定树上的一个顶点为**树根**（root）。和大自然中的树不一样，树上的任何一个节点，包括叶子，都可以当做树根。

以上一节图中的树为例，下面展示了分别以A-F为树根得到的形态：

![树根](../../pic/ds/树根.png)

在确定了树根`r`之后，对于树`T`上的其他节点`v`，定义`v`的**深度**`depth(v)`为`v`到树根`r`的唯一路径的**长度**。

比如在上面的黄色树中，`A`是树根，那么`depth(B) = 1`，而`depth(C) = 2`。特别地，树根的深度`depth(r)`定义为`0`。规定了深度之后，就可以让同一深度的顶点排在一层，画成上面这种形式的图。对于深度为`k`的顶点`v`，就称`v`位于第`k`层。

> 有些教材会定义树根在第1层而非第0层，这违反了计算机学科从0开始计数的思维方式，从而会导致后面的一些等式和不等式多出一个额外的+1项，既不美观又不方便记忆。
>
> 考研试卷上如果出现这种定义，就是出卷老师刻意想坑一手没注意到的同学，请务必注意这个额外的+1。

上图中的6个树，尽管<u>在数学角度上看是拓扑同构的</u>，但是因为<u>规定的树根不同</u>，所以<u>在计算机角度上看是不同的树</u>。这是因为，在计算机角度研究的树，总是**有根树**，即定义了树根的树。之后如无特殊说明，笔记中所说的树都是有根树。

给定树的拓扑结构，根据给定的树根画出对应的有根树，这是一项基础技能，您应该已经掌握它了。

### 节点的关系

接下来介绍关于树的其他概念。

对于任意节点`v`，在`v`通往树根`r`上的唯一路径上的所有节点，都是`v`的**祖先**（ancestor），`v`是它们的**后代**或**子孙**（descendant）。<u>一个节点总是它自身的祖先和后代</u>。自身以外的祖先（后代）称为**真祖先**或**真后代**。

显然，一个位于第`k`层的节点，它的真祖先分别在第`k-1`、`k-2`、……、`1`、`0`层，一共`k`个。将它位于第k-1层的祖先，也就是和它直接有边相连的祖先称为它的**亲代**或**亲节点**（parent）。相应地，一个节点是它的亲代的**子代**或**子节点**（child）。拥有共同亲代的节点之间互为**姊妹**（sibling）。

> 这里稍微说明一下这几个名词的选取。
>
> parent、child和sibling最常见的翻译是“**父亲**”、“**儿子**”和“**兄弟**”，这种将数据结构树当成父系亲族树的说法还有“**堂兄弟**”“**祖父**”等（定义不再赘述），笔者认为这些写法不太妥当。另一些观点激进的翻译者，会将其翻译成“**母亲**”、“**女儿**”和“**姐妹**”，笔者认为这同样不妥当。
>
> > 在英文语境下，使用father、daughter等词语的文章也很多，因为读者都知道这些词汇的意义，所以并不会影响阅读和理解。当然，随着性别平等意识的兴起，近年的英文文献已基本规范为parent、child和sibling；但国内的文章有些翻译自较为古早的英文文献，因而<u>有可能是沿用了英文原文的性别色彩，并不是翻译者采用了带有性别色彩的译法</u>。
>
> 但是，parent常见的中性化翻译“**双亲**”有严重的误导性，容易让人误认为一个节点有2个parent。这个问题比“父亲”、“母亲”更加严重。
>
> 所以，在这本笔记中使用了一个冷门翻译“**亲代**”。
>
> 对于child，常见的中性化翻译“**孩子**”没有这个问题，不过为了对应，这里采用的也是冷门翻译“**子代**”。
>
> 对于sibling，直接沿用了常见的中性化翻译“**姊妹**”。
>
> 笔者相信虽然用的词汇不同，但您都是可以理解并轻松能够转换的。
>
> 在考试试卷上以上所有译名都可能出现，您应该采用和试卷上一样的译名。如果试卷没有给出，用上面任意的译名都是可以的。

### 子树

一个节点`v`的子节点数量称为它的**度数**或**度**（degree），记作`deg(v)`。

没有子节点（度为0）的节点称为**叶节点**或**叶子**（leaf）。

> 在规定了树根的树中，叶子都采用这个定义，而不是前面那个“只和一条边相连”的数学上的定义。
>
> 这两者的区别在于，<u>有且只有一个子节点的树根在这个定义下不再是叶节点</u>。因此，对于有根树而言，只能保证<u>非空树中至少有一片叶子</u>。

叶节点以外的节点统称为**内部节点**（internal node）。

一个节点`v`的所有后代及连接这些点的边也构成一棵树（您可以使用递降法证明），称为以节点`v`为根的**子树**`subtree(v)`。

> 子树的存在，意味着树可以被**递归定义**。
>
> 1. 递归边界：平凡树。
> 2. 一共`n`棵树，
>
> 因此，树上的命题总是可以用下面的递降法证明。
>
> 1. 要证明命题对树`T`成立，只要证明对于`T`的根节点的每个子节点`v`，命题对`subtree(v)`成立。
> 2. 递归边界：命题对平凡树成立。

因为一个节点就对应了一棵子树，所以在不引起歧义的情况下，节点和子树这两个词可以互相指代。

在树`T`中，所有节点深度的最大值称为树`T`的**高度**，记作`height(T)`，特别地，规模为`0`的空树的高度为`-1`。

对于树上的任意节点`v`，称以`v`为根的子树`subtree(v)`的高度，为`v`的**高度**`height(v)`。树的高度和根节点的高度相等。

**对于树T上的任意节点v，都有`depth(v) + height(v) <= height(T)`。**

> 这个命题您可以用上述的递降法轻易证明。

如果树上的每个节点的度数都不超过1，这棵树就<u>退化成了一条链</u>。退化成链的树，每一层都只有1个节点，它常常作为“最坏情况”的例子被用来分析一些算法在最坏情况下的复杂度，在后续章节中将会看到它发挥作用的地方。

另一种常常作为“最坏情况”的例子是<u>菊花图</u>。即，除了根之外，所有的节点都是叶子，整棵树只有2层。由于在拓扑上，这种树可以被画成一个中心节点辐射出`n-1`个“花瓣”节点的形状，所以被称为菊花图。

### 二叉树与有序树

如果树上的每个节点的度数都不超过2，则称其为**二叉树**（binary tree，下面简称为BT）。

> 因为计算机是二进制的，所以二叉树相对于一般的树，更适合在计算机中进行处理和分析。在下一节，您将会看到任何一棵普通的树或者森林，都可以被转换成二叉树进行处理。

在二叉树中，每个亲节点至多有2个子节点，所以可以用左、右来区分它们。

为了让对二叉树的分析讨论更具有一般性，可以将空树纳入讨论。这样，如果一个节点只有1个子节点，如只有左子节点，则认为，它的右子树是一棵空树。如果一个节点是叶子，则认为它的左右子树都是空树。这样，就使得对于二叉树上的每一个节点，都可以定义它的左右子树。

> 从数学角度看，交换左、右子树不会影响树的拓扑结构，但在计算机中存储数据总是有先后的，不存在真正意义上的、元素地位完全对称的“集合”。所以研究的总是**有序树**。
>
> 由于有序性，下图中的各树都是不相同的树。

![有序树](../../pic/ds/有序树.png)

有序性和有根性一样，都是计算机领域的树，相对数学上的树所需要满足的特殊性质。

> 在二叉树的场合，有序性比一般的树更加严格。
>
> 如果一个节点只有一个子代，那么对于一般的树而言，有序性的限制并不对这个节点起作用。
>
> 但对于二叉树而言，这个子代是左子代还是右子代，对应的是不同的二叉树。在这个地方，可以理解成二叉树的每一个节点都有两棵子树。如果两棵子树都是空树，则它是叶子节点，并且交换两棵子树得到的是同一棵树。只要有一棵子树不是空树，那么交换两棵子树得到的就不是同一棵树。

### 满二叉树

对于一般的二叉树而言，内部节点的度数是可以为1的，也就是说，可以只有左子代，或者只有右子代。而如果每个内部节点的度数都为2（既有左子代又有右子代），则称其为**真二叉树**（proper BT）。

如果一棵真二叉树的所有叶子节点都在最底层，则它称为**满二叉树**（full BT）。满二叉树是特殊的真二叉树。

显然，平凡树都是真二叉树，并且也都是满二叉树。从定性的角度看，满二叉树是“图形被填得最满的二叉树”；从定量的角度看，则有下面的几个命题。

**命题1. 在一棵二叉树中，深度为k的节点至多$2^k$个。**

**命题2. 一棵高度为h的二叉树至多有$2^{h+1}-1$个节点。**

**命题3. 高度为h的满二叉树恰好有$2^{h+1}-1$个节点。**

> 上述命题都可以由归纳法证明。
>
> 在考试时使用公式的时候，只需要验证空树（规模0、高度-1），就可以验证自己的记忆是否出现了偏差；如果记忆有错，当场重新推导也并不困难。理解推导方法，会用特殊情况验证，就可以大大降低公式的记忆量。
>
> 另一方面，对于考试现场计算的更加复杂的公式，常常也可以通过平凡树、链、菊花图、满二叉树等典型的结构来进行验算。

### 完全二叉树

如果一棵二叉树满足：

1. 叶子节点都分布在最底层和次底层。
2. 最底层的叶子都分布在次底层叶子的左侧。
3. 若删去最底层的叶子，则得到一棵满二叉树。

则其称为**完全二叉树**（complete BT）。

满二叉树是特殊的完全二叉树。当然，作为特殊的满二叉树，平凡树也都是完全二叉树。

可以看出，完全二叉树的定义依赖于树的有序性。为了理解完全二叉树，您可以自己画图给出反例，从而证明下面的两个命题。

**命题1. 满二叉树既是完全二叉树，又是真二叉树。但，既是完全二叉树，又是真二叉树的不一定是满二叉树。**

**命题2. 完全二叉树不一定是真二叉树，真二叉树也不一定是完全二叉树。**

一个参考的图例如下。

![完全二叉树](../../pic/ds/完全二叉树.png)

> 从左到右：
>
> 树1：满二叉树，完全二叉树，真二叉树。
>
> 树2：完全二叉树，真二叉树，但不是满二叉树。
>
> 树3：完全二叉树，但不是真二叉树。
>
> 树4：真二叉树，但不是完全二叉树。

完全二叉树可以看成是满二叉树的推广。满二叉树具有非常良好的性质，但受限于规模n只能是$2^{h+1}-1$​​​的形式，很难得到具有一般性的结果。将满二叉树推广成完全二叉树之后，仍然满足“图形被填得非常满”的特征，并且规模n可以是任意的。

由完全二叉树的定义，很显然地可以由上一小节得到的满二叉树规模公式，得到下面的**命题3**。

**命题3. 高度为h的完全二叉树，满足$2^h\le n\le 2^{h+1}-1$。**

> 左边的不等号在最下层只有一个叶子节点时满足；右边的不等号在满二叉树时满足。

此外，因为完全二叉树利用有序树的特性，规定了最下层叶子排列的位置，所以可以得到下面的**命题4**。

**命题4. 任给n，在规模为n的有序有根树中，有且只有一个是完全二叉树。**

这个命题指出，给定规模时，完全二叉树的结构是固定的。这使得当讨论完全二叉树的时候，可以不需要做结构上的分情况讨论，提供了分析上的简便。

### 带标号树

对于完全二叉树，只要给定规模n，就只存在一个满足条件的有序有根树。但是，这棵有序有根树上的节点显然是不同的数据单元。交换完全二叉树上的两个节点的位置，得到的显然是一棵新的树，尽管它的结构形态和原来的树完全一样。

> 有序树说明，同一个节点的两个子树交换位置，是两棵树。
>
> 带标号树说明，两个节点交换位置，是两棵树。

为了将不同的数据单元区分开，在有根有序树的基础上引入了标号。通常，将树上的每个节点标号为`0, 1, ..., n-1`；在各个节点存储的数据互不相同时，有时也用存储的数据为节点标号；此外，在示意图等场合，也可以用字母为部分节点标号。标号的唯一原则是<u>保证互不相同，从而可以区分不同的节点</u>。

为树上的节点做标号之后，就可以得到一棵**带标号树**。在绘制带标号树的时候，通常将标号写在代表节点的圈内。

> 到此为止，得到了计算机领域的树在数学上的定义：
>
> **树（计算机）是有根的、有序的、带标号的、有限的树。**
>
> 后文中，凡是不加指明地使用的“树”，均指**树（计算机）**。

由于节点和标号是一一对应的，所以在叙述时有时不对它们做区分。

### 根据树的性质建模

这一节中出现了很多定义，在考研的《数据结构》中，通常不会出现对于概念定义的考察，而是在理解概念的基础上，要求学生做一些简单的计算。和栈或队列要求您画图枚举不同，树相关的计算题通常数字比较大，让您列出方程或不等式求解。

方程或不等式的变量设法通常有两种，一种是按度设变量，一种是按层设变量。

> 笔者希望您掌握讨论此类题目的一般方法，而不是去记住尽可能多的结论。

**按度设变量**：在涉及度数的问题中通常采用按度设变量的方法。在二叉树中，设$n_0$​、$n_1$、$n_2$分别为度为0、1、2的节点数量（如果题目中有区分左右子代，则可以进一步将$n_1$拆分为$n_l+n_r$），就可以得到下面的限制条件：

1. $n_0­ + n_1 + n_2 = n$。（根据总节点数列出方程）

2. $n_1 + 2n_2 = n - 1$​。（根据总边数列出方程）

3. 如果是满二叉树，$n_1 = 0$且$n_0 = n_2 + 1$；

   如果是完全二叉树，$n_1 \le 1$；

   如果是真二叉树，$n_1 =0$。

**按层设变量**：在涉及高度的问题中通常采用按层设变量的方法。在二叉树中，设$n_k$​为第$k$层的节点数量（$k = 0, 1, 2, ..., h$），其中$h$​为树高（待定），就可以得到下面的限制条件：

1. $n_0 + n_1 + \dots + n_h = n$​。（根据总节点数列出方程）
2. $n_0 = 1$。（只有1个根节点，若不考虑空树的情况）
3. $1 \le n_k \le 2n_{k-1}$​。（根据二叉树性质列出不等式）如果是满二叉树，则对所有的$k$​都取等号；如果是完全二叉树，则对除$k = h$​外的$k$​都取等号。

对于一般的、非二叉的树，也可以列出类似的方程。

> 如果既涉及度数的问题，又涉及高度的问题，则可能需要将上面两种方法结合起来列出方程和不等式。

### 针对树的性质求解

下面从几个典型问题出发，应用这两种思路。

**问题1. 已知一棵完全二叉树有$l$个叶子结点，求它的总节点数。**

> 相当于在条件
> $$
> \begin{cases}
> l+n_1+n_2=n\\
> n_1+2n_2 =n-1\\
> n_1 \le 1
> \end{cases}
> $$
> 的条件下求$n$。将$n_1 = 0$和$n_1 = 1$分别代入，可以得到两个二元一次方程组，分别解之即可得$n$的两个可能值。

**问题2. 设一棵k叉树（k >= 2）的节点数为n，求它的叶子数量的取值范围。**

> 相当于在条件
> $$
> \begin{cases}
> n_0 + n_1+n_2+\dots+ n_k=n\\
> n_1+2n_2+\dots+kn_k =n-1
> \end{cases}
> $$
> 两个限制条件下，求$n_0$​的最大值和最小值。由于$n_i$​被限制为非负整数，使用Lagrange乘数法求解并不方便，应当使用不等式代换。
>
> 显然$n_0$的最小值是1（前面介绍过，有根树至少有一个叶子；并且在树退化成链的时候可以取到）。
>
> 为了让$n_0$​取最大，则$n_1 + n_2 + \dots + n_k$​应该尽可能小，而
> $$
> n_1+n_2+\dots+n_k\ge \frac 1k (n_1+2n_2+\dots+kn_k)=\frac{n-1}k
> $$
> 如果$(n-1)\%k=0$，则当$n_k = (n-1)/k$，其余为$0$时取最小；
>
> 如果$(n-1)\%k\ne 0$，则当$n_k =\lfloor                                 (n-1)/k\rfloor$  ，$n_{(n-1)\%k} = 1$，其余为$0$时取最小。

**问题3. 设一棵k叉树（k >= 2）的节点数为n，求它的高度的取值范围。**

> 相当于在条件
> $$
> \begin{cases}
> n_0+n_1+n_2+\dots+n_h=n\\
> n_0=1\\
> 1\le n_i\le kn_{i-1}
> \end{cases}
> $$
> 的限制条件下，求$h$的最大值和最小值。
>
> 最大值仍可以通过将树退化成链算出，此时$h + 1 = n$，$h_{max} = n-1$。
>
> 最小值则通过
> $$
> n = n_0 + n_1 + n_2 + ... + n_h \le 1 + k + k^2 + ... + k^h = \frac{k^{h+1}-1}{k-1}
> $$
> 可以算出，此时对应完全k叉树的情况。

另外，除了由于此类题目总是以选择题出现，所以您也可以直接取一些极端情况来快速得到答案。常用的极端情况包括完全k叉树、退化成链、菊花图和双链（向一个方向延伸的链，叶子作为另一个方向的子代挂在链上）。

## 二叉树

上一节介绍的内容都是理论性的，这一节回到实际代码的实现上来。因为二叉树最为重要，本节先从二叉树出发展开讨论。随后，再迁移到一般的树和森林。

### 二叉树的节点

因为二叉树上的节点，和列表一样，通过“链子”（亲代和子代之间的连边）连接，所以实现的方法也和列表有相似性。首先，对于单个的节点，定义一个结构体封装各个“链子”（指针）。

```c++
template <typename T>
struct BTNode {        // 二叉树的一个数据单元（节点）
    T value;           // 本节点存放的数据
    BTNode<T>* parent; // 指向本节点的亲节点
    BTNode<T>* lc;     // 指向本节点的左子代
    BTNode<T>* rc;     // 指向本节点的右子代

    // 判断是否是树根、左子代、右子代
    bool isRoot() const { return parent == nullptr; }
    bool isLeftChild() const { return !isRoot() && parent->lc == this; }
    bool isRightChild() const { return !isRoot() && parent->rc == this; }
    
    BTNode<T>(T e): value(e), parent(nullptr), lc(nullptr), rc(nullptr) {}
};
```

> 在上面的代码中，节点里既保存了指向亲节点的指针`parent`，又保存了指向子节点的指针`lc`和`rc`，因此被称为**亲代+子代表示法**。
>
> 就像双链表可以通过去掉一个方向的指针，变成单链表一样，“亲代+子代表示法”的二叉树也可以去掉一个方向的指针。
>
> 1. 如果去掉从子代指向亲代的指针`parent`，只保留指向子代的指针，则称为**子代表示法**。和单链表一样，它可以实现大多数的二叉树操作，因此有时会用来替代“亲代+子代表示法”，降低空间占用。
>
>    在后文介绍各个算法的时候，您可以自己思考是否可以在子代表示法上实现。
>
> 2. 如果去掉从亲代指向子代的指针`lc`和`rc`，只保留指向亲代的指针，则称为**亲代表示法**。“亲代+子代表示法”的绝大多数操作都无法被迁移到亲代表示法，因此这种表示法非常少见，也不是考研的重点。
>
> 由于有根树的性质，从树根沿着`lc`或`rc`指针，必然能够有一条路径到达树上的任一节点。
>
> 所以，在子代表示法中，任何节点都可以从树根出发探测到，从而在`BinaryTree`类中只需要保存树根。
>
> 但在亲代表示法中，这一性质不再满足，只能使用一个线性表来存储所有的节点。

在列表的场合，设计头尾哨兵可以有效地减少特殊情况的讨论。而在二叉树的场合，通常不需要增加“树根哨兵”和“叶子哨兵”，因为它们的用处不大。并且，树根哨兵会破坏二叉树的对称性（树根无论是树根哨兵的左子代还是右子代，都会造成二叉树向一个方向偏）；叶子哨兵则可能会浪费大量的空间（叶子的数量有可能是$\Theta(n)$​的）。

因此，在本章中，树根的`parent`指向`nullptr`，叶子的`lc`和`rc`、以及度为1节点没有子代的那一边，也指向`nullptr`。

### 二叉树的删除

根据上一节的分析，对于“亲代+子代表示法”，任何节点都可以从树根出发探测到，从而在`BinaryTree`类中只需要保存树根。二叉树的模板可以定义如下。

```c++
template <typename T>
class BinaryTree {
private:
    int _size;         // 二叉树的规模
    BTNode<T>* _root;  // 指向二叉树的根节点
public:
    int size() const { return _size; }
    BTNode<T>* root() const { return _root; }  
    BinaryTree(): _size(0), _root(nullptr) {} // 构造函数，生成空树
};
```

要讨论二叉树的删除，首先会遇到的，是语义问题。

> 因为二叉树不再是线性结构，所以在插入或者删除一个新的节点时，语义会没有线性结构那么明确，需要进行明确。

首先，删除一个叶子节点，语义是清楚的。但如果删除一个内部节点，那么它的叶子应该如何处理呢？

1. 一并删除，即将删除的语义定义为<u>删除子树</u>。
2. 不删除，而是替代被删除节点的位置。如果被删除节点只有一个子树，那么很容易这么处理；但如果被删除节点有两个子树，则语义仍然是模糊的，没有显而易见的规定。

因此，如果使用不删除策略，往往需要对二叉树做额外的限制，使得被删除节点有两个子树的情况下，能够做出合理的语义规定。在这一章讨论的是一般意义的二叉树，所以使用的是删除子树的语义。

```c++
// 算法4.1 - 二叉树的删除
// 给定：二叉树T
// 输入：被删除子树的根节点node
// 要求：将以node为根的子树删除
```

由于是链式结构，所以在删除以`node`为根的子树时，必须要释放整棵子树上的所有节点的内存空间。由于树是递归定义的，这个释放空间的过程也可以很容易地使用递归方法解决。

```c++
// 算法4.1
template <typename T>
void BinaryTree<T>::removeSubtree(BTNode<T>* node) {
    function<void(BTNode<T>*)> remove;
    remove = [&_size](BTNode<T>* node) -> void {
        if (node == nullptr) { // 递归边界：空树
            return;
        }
        auto lc = node->lc, rc = node->rc;
        --_size;               // 每删除一个节点，更新一次二叉树规模
        delete node;           // 释放当前节点的空间
        remove(lc);            // 递归删除左右子树（尾递归）
        remove(rc);
    };
    if (node->isRoot()) {      // 首先把子树从整棵二叉树上分离出来
        _root = nullptr;
    } else {
        if (node->isLeftChild()) {
            node->parent->lc = nullptr;
        } else {
            node->parent->rc = nullptr;
        }
    }
    remove(node);              // 递归删除子树
}
```

容易被忽略的一点是，需要首先把子树从二叉树的其他部分中分离出来。如果遗漏了这一步，那么就会导致被删除子树的亲节点，会有一个指向子代的指针，因为子树被删除而成为野指针。

另外，`remove`函数是一个典型的尾递归，您可以利用上一章介绍的方法，将它改写成使用栈的无递归形式。

### 二叉树的插入

下面讨论二叉树的插入问题，同样，首先需要明确语义。

插入一个叶子节点，语义同样是清楚的。而把新插入的节点放在内部节点的位置上，则有一个问题：原先占有待插入位置的“旧节点”，在插入之后应该放在哪里呢？无论是放在新节点的左子代还是右子代，都属于“强行规定”，会破坏二叉树的对称性。为了保证对称性，有两种做法：

1. 直接把“旧节点”及其子树删掉。
2. 随机放在新节点的左边或右边。

在这一章，仍然只讨论最简单的情况，即，采用直接删除的语义。

```c++
// 算法4.2 - 二叉树的插入（左子）
// 给定：二叉树T
// 输入：被插节点p，待插入元素e
// 要求：将存储e的节点插入到p的左子代位置
//      如果这个位置原先有子树，则将这个子树删除
```

这个算法的设计可以参考在列表的末尾添加节点，只需要连上“链子”即可。

```c++
// 算法4.2 - 插入节点（左子）
template <typename T>
void BinaryTree<T>::insertAsLeftChild(BTNode<T>* p, T e) {
    removeSubtree(p->lc);                    // 删除原位置的子树
    (p->lc = new BTNode<T>(e))->parent = p;  // 插入新的叶子
    ++_size;                                 // 更新规模
}
```

插入为右子的情况相似，您可以自己写出。

> 注意，插入操作除了左子、右子之外，还有非常特殊的一个位置：根节点。根节点不是任何节点的左子代或者右子代，所以需要单独为插入为根节点写一个函数。

### 二叉树的递归遍历

下面讨论在二叉树上的查找问题。在线性表上做查找，只需要从线性表的开头到线性表的结尾，依次访问即可。但在二叉树上做查找，首先需要确定一个查找次序，使得能够“不重不漏”地访问到二叉树上的每一个节点。这个过程就是二叉树的**遍历**（traverse），从抽象的角度上说，就是**半线性结构的线性化**。

从递归的角度出发，可以很自然地想到，在二叉树`T`中遍历可以分成三步：

1. 访问树根`root`；（N，Node）
2. 递归地访问左子树`root->lc`；（L，Left）
3. 递归地访问右子树`root->rc`。（R，Right）

因为子树高度总是小于原树高度，所以最终可以达到递归边界（平凡树）。

本着这一思路，可以得到`3! = 6`种遍历方法。作为有序树，可以硬性规定，左子树总是先于右子树被访问；从而得到3种遍历方法（NLR、LNR、LRN）。

> 由于这三种遍历在这一节会讲的非常细致，有可能会有一些学生直接背诵了所有知识点；所以另外3种遍历方法（NRL、RNL、RLN），仍然有可能出现在试卷上，以考察您对二叉树遍历的实际掌握程度。

根据“访问树根”操作的位置，将NLR、LNR和LRN，分别称为**先序遍历**（pre-order traverse，又称**前序遍历**）、**中序遍历**（in-order traverse）、**后序遍历**（post-order traverse）。

```c++
// 算法4.3A - 先序遍历
template <typename T>
void BinaryTree<T>::preorderTraverse(function<void(BTNode<T>*)> visit) {
    function<void(BTNode<T>*)> traverse;
    traverse = [&visit](BTNode<T>* node) -> void {
        if (node == nullptr) {  // 递归边界：空树
            return;
        }
        visit(node);            // 访问树根
        traverse(node->lc);     // 递归遍历左子树
        traverse(node->rc);     // 递归遍历右子树
    };
    traverse(_root);            // 从整棵树的树根开始遍历
}

// 算法4.3B - 中序遍历
template <typename T>
void BinaryTree<T>::inorderTraverse(function<void(BTNode<T>*)> visit) {
    function<void(BTNode<T>*)> traverse;
    traverse = [&visit](BTNode<T>* node) -> void {
        if (node == nullptr) {  // 递归边界：空树
            return;
        }
        traverse(node->lc);     // 递归遍历左子树
        visit(node);            // 访问树根
        traverse(node->rc);     // 递归遍历右子树
    };
    traverse(_root);            // 从整棵树的树根开始遍历
}

// 算法4.3C - 后序遍历
template <typename T>
void BinaryTree<T>::postorderTraverse(function<void(BTNode<T>*)> visit) {
    function<void(BTNode<T>*)> traverse;
    traverse = [&visit](BTNode<T>* node) -> void {
        if (node == nullptr) {  // 递归边界：空树
            return;
        }
        traverse(node->lc);     // 递归遍历左子树
        traverse(node->rc);     // 递归遍历右子树
        visit(node);            // 访问树根
    };
    traverse(_root);            // 从整棵树的树根开始遍历
}
```

可以看出这三个函数只有递归次序的区别。

默认`visit`函数的时间、空间复杂度都是$O(1)$​的，那么您可以利用递归法，轻松证明三种遍历的时间复杂度都是$\Theta(n)$​，空间复杂度都是$\Theta(h)$​，其中`h`为二叉树的高度。在退化成链的情况下，空间复杂度会取到最坏的$O(n)$​；而在完全二叉树的情况下，空间复杂度可以取到最好的$\Omega(\log n)$​。

### 用先序序列和中序序列重建二叉树

当使用先序遍历对二叉树进行遍历时，各个节点可以按照被访问的次序组成一个序列，称为**先序序列**。同理可以定义**中序序列**和**后序序列**。由于算法的确定性，对于一棵给定的二叉树，它的先序、中序和后序序列都是唯一的。

那么，就会自然地想到，如何基于先序序列、中序序列或后序序列，对二叉树进行重建呢？

> 首先，您可以递归证明，<u>先序序列（NLR）和后序序列（LRN）是具有对称性的</u>。
>
> *如果将二叉树中每一个节点的左右子树交换位置，再进行先序遍历，则得到的NLR序列相当于原二叉树的NRL序列，也就是原二叉树后序序列的反序*。
>
> 所以，先序序列+中序序列的情况，和后序序列+中序序列的情况，是对称的。在这一小节，笔者介绍利用先序序列和中序序列重建二叉树的方法，您可以在理解的基础上，自己推导利用后序序列和中序序列重建二叉树的方法，并用代码实现它。

```c++
// 问题4.4 - 重建二叉树（先序+中序）
// 输入：先序序列preSeq，中序序列inSeq
// 输出：重建的二叉树T
```

一个朴素的想法是，先序序列是NLR，中序序列是LNR，所以，先序序列的第一个元素就是二叉树T的树根`r`。在中序序列中寻找这个树根`r`的位置，`r`将中序序列分成了两部分，前半部分是`r->lc`的中序序列，后半部分是`r->rc`的中序序列。根据这两个序列的长度，对先序序列作出划分，也可以得到`r->lc`的先序序列，以及`r->rc`的先序序列。这样，算法就可以对两个子树递归下去；最终到达递归边界（空树）。

```c++
// 算法4.4A
template <typename T>
BinaryTree<T> rebuildBinaryTree1(const Vector<T>& preSeq, const Vector<T>& inSeq) {
    function<BTNode<T>*(int, int, int)> buildSubtree;
    buildSubtree = [&](int preSeqStart, int inSeqStart, int length) -> BTNode<T>* {
        // 从 preSeq[pSS:pSS+len] 和 inSeq[iSS:iSS+len] 重建二叉树
        for (int i = 0; i < length; ++i) {   // 找子树的根在中序序列上的位置
            if (inSeq[inSeqStart + i] == preSeq[preSeqStart]) { // 先重建树根
                auto r = new BTNode<T>(preSeq[preSeqStart]);    // 在重建左右子树
                r->lc = buildSubtree(preSeqStart + 1, inSeqStart, i);
                r->rc = buildSubtree(preSeqStart + i+1, inSeqStart+i+1, length-1 - i);
                return r;
            }
        }
        return nullptr; // 递归边界：空树（length=0，不会进循环）
    };
    buildSubtree(0, 0, preSeq.size());
}
```

在**算法4.4A**中，由于在中序序列中找树根的过程是最坏$\Theta(n)$​的，所以可以证明，整个算法是最坏$\Theta(nh)=O(n^2)$​​的（退化成链，且所有内部节点都只有左子代时，取到$\Theta(n^2)$）。这个时间复杂度并不能够让人满意。

从“冗余计算”的角度来分析，**算法4.4A**中，在中序序列中找树根的过程，本质上是对先序序列中元素和中序序列中元素的一一比较，即判断是否`inSeq[inSeqStart + i] == preSeq[preSeqStart]`。由于每次递归过程中，树根`preSeq[preSeqStart]`都不会被传下去，所以这些比较是没有重复的。因此，在“冗余计算”的角度上，**算法4.4A**已经没有多少优化空间了。

那么，要对**算法4.4A**进行优化，必须要对先序序列和中序序列的性质有着更加深刻的理解，从“充分利用信息”的角度，开辟新的道路。笔者将这个问题留到详细分析各种遍历之后。

> 本节介绍的内容有一个经典的推论：<u>已知先序序列和中序序列，可知后序序列</u>。（类似，<u>已知后序序列和中序序列，可知先序序列</u>）
>
> 这个问题可用来作为选择填空题，其本质仍然是重建二叉树，而非直接从两个序列推出另一个序列。

### 用先序序列和后序序列重建二叉树

如果已知的是先序序列和后序序列，则没有上一小节那么好的性质。

<u>已知先序序列和后序序列，有可能重建出不唯一的二叉树</u>。比如说，先序`(1,2)`，后序`(2,1)`的情况，无论2号节点是1号节点的左子代还是右子代，都满足给定的先序序列和后序序列。

<u>已知先序序列和后序序列，有可能重建出唯一的二叉树</u>。比如说，先序`(1,2,3)`，后序`(2,3,1)`的情况，您可以自己分析。

<u>已知先序序列和后序序列，有可能无法重建出二叉树</u>。比如说，先序`(1,2)`，后序`(1,2)`的情况，就无法重建出二叉树。

> 虽然性质很差，但在选择填空题中，仍然有可能要求讨论，在给定先序序列和后序序列的情况下，可以重建出多少棵二叉树。
>
> 和上一小节相似，可以推导出一个递归的计算方法。

首先，仍然可以将这两个序列分成`r`、`r->lc`和`r->rc`三个部分。

根`r`既是先序序列的第一个元素，又是后序序列的最后一个元素（若不满足此性质，则无法重建）。

下面考虑先序序列的第二个元素`c`。当`c`是后序序列的倒数第二个元素时，说明`r`只有1个子树（有左子树和右子树2种可能），该子树的先序（后序）序列就是整个树的先序（后序）序列除去`r`的部分。

当`c`不是倒数第二个元素时，说明`r`有2个子树，而`c`是左子树的根，从而`c`是`r->lc`的后序序列的最后一个元素，所以观察`c`在后序序列中的位置，就可以得到`r->lc`和`r->rc`的后序序列，并由其规模划分出`r->lc`和`r->rc`的先序序列。

> 可以看出，重建出的二叉树不唯一的原因，在于只有一棵子树的情况下，这棵子树在左还是在右都可以，不会影响到先序序列和后序序列。
>
> 因此，只需要重建出一棵二叉树，然后观察这棵二叉树上有多少个度为1的节点。当有`k`个度为1的节点时，则总共能重建出的二叉树数量为$2^k$​​​。您可以仿照上一小节的算法，构造一个利用先序序列和后序序列重建*一棵*二叉树的算法。
>
> 因为先序（或后序）序列给定的情况下，已知中序序列可以唯一构造出二叉树。所以，给定先序序列和后序序列，可以得到的中序序列数量，也是$2^k$​。

利用两个序列去重建二叉树，是二叉树遍历这个知识点上需要掌握的一项基本技能。

> 在配套代码中有随机生成二叉树的程序，您可以借助它自己练习。您应该很快就掌握了它。

### 二叉树的计数

在这一小节，如果只知道*一个序列*，可以重建出多少个二叉树。

> 实际上，这个问题等价于规模为`n`的二叉树有多少种结构（有根、有序、无标号）。
>
> 因为给定一个二叉树的结构，其在某种遍历下各个节点被访问的次序是确定的，对应已知的遍历序列就可以知道每个节点上是什么值。

设规模为`n`的二叉树有`T(n)`种结构，则递归边界是`T(0) = T(1) = 1`。为了计算`T(n)`，设树根的左子树有`k`个节点（`0 <= k <= n-1`），则右子树有`n-1 - k`个节点。于是，可以列出递归方程：
$$
T(n)=\sum_{k=0}^{n-1}T(k)\cdot T(n-1-k)
$$
相信您一定不会忘记这么经典的一个递归方程：这是上一章节介绍过的Catalan数的递归方程。

所以，由`n`个节点组成的二叉树恰好有$\mathrm{Catalan}(n)$种结构。亦即，如果只知道先序序列、中序序列、后序序列之一，可以构造出$\mathrm{Catalan}(n)$棵不同的二叉树。

### 表达式树

您一定对上一小节得到的结果$\mathrm{Catalan}(n)$​非常感兴趣。在介绍Catalan数的时候笔者曾经介绍过，计数问题有递归方程法和一一映射法两种途径，而如果用递归方程法求出结果是Catalan数，那一定存在某种一一映射关系，可以把待求解的计数问题，映射到出栈序列问题上。

从推导递归方程的角度，很容易建立下面的一一映射：

1. 对于空树，对应空的操作序列。
2. 对于根为`r`的树，设其左右子树对应的操作序列为`A`、`B`，则其对应的操作序列为`push(r) A B pop(r)`。

那么，可以用递归的方法，迅速在二叉树和栈之间建立桥梁：

1. 二叉树的先序序列，即对应操作序列的入栈序列。
2. 二叉树的后序序列，即对应操作序列的出栈序列。

> 入栈序列和出栈序列对应于何种二叉树的遍历序列，取决于上面的操作序列中，`push`、`pop`和两棵子树的位置关系。
>
> 在上面使用的操作序列是`push(r) A B pop(r)`。可以看出，如果用L、R代替`A`和`B`，用N代替`push`或`pop`，那么`push`（入栈序列）对应的就是NLR（先序序列），`pop`（出栈序列）对应的就是LRN（后序序列）。
>
> 将这个位置关系作出调整，比如说，如果使用`push(r) A pop(r) B`，那么入栈序列仍然对应先序序列，出栈序列变为对应了后序序列。您可以自己建立映射，让入栈序列对应中序序列，而出栈序列对应后序序列。
>
> 在这一小节为了引出和表达式的关系，选用了先序+后序的对应关系，您应当明白这不是唯一的一种映射方式。

您一定能够回忆起，在上一章中，表达式也分别对应了入栈序列和出栈序列。

1. 前缀表达式，对应操作序列的入栈序列。
2. 后缀表达式，对应操作序列的出栈序列。

所以，二叉树可以和表达式之间建立起一一对应的关系。由表达式转换得到的二叉树，称为**表达式树**。

> 严格来说，表达式树并不一定是二叉的，因为允许三目甚至多目运算符的存在。在这里为了方便，暂时认为表达式树中只包含双目或单目运算符。
>
> 对于单目运算符，可以认为它是一个操作数为空的双目运算符。比如，负号运算符：`-A`相当于`NULL - A`，而阶乘运算符：`A!`相当于`A ! NULL`。这里`NULL`表示操作数为空，在转换成二叉树时它对应空子树，从而能够既不出现在前缀/后缀表达式中，又不出现在先序/后序序列里。
>
> 这样，表达式中的所有运算符就都可以认为是双目的了，从而可以自然地使用二叉树表示。
>
> 在后面的几个小节里，都只讨论双目运算符（加、减、乘、除、乘方）的情况；配套代码中实现了一个包含负号和阶乘的例子。

表达式树可以被递归定义。

1. 空表达式对应空树。
2. 设表达式计算中的最后一步计算为$\oplus (A_1,A_2,\dots,A_n)$，其中$\oplus$为运算符，$A_1,A_2,\dots,A_n$为参与$\oplus$运算的子表达式（如最后一步为加法时，最后一步为$A_1 + A_2$）。那么，对应的表达式树的树根为$\oplus$，树根的子树依次为$A_1,A_2,\dots,A_n$对应的表达式树。

如上所述，当讨论所有运算符均为双目的表达式树（二叉树）时，有下面的性质：

1. 表达式树的先序遍历，是前缀表达式。
2. 表达式树的后序遍历，是后缀表达式。
3. 表达式树的中序遍历，在增加了表示运算次序的括号之后，是中缀表达式。

### 用后缀表达式构造表达式树

从上一小节可以得到，只要知道三种表达式中的一个，就能够推出前缀表达式和后缀表达式，从而可以唯一确定入栈序列和出栈序列，从而也能唯一确定`push`和`pop`组成的操作序列。这$\mathrm{Catalan}(n)$个操作序列，恰好能对应$\mathrm{Catalan}(n)$​​种二叉树的结构；再加上入栈序列（先序序列）或出栈序列（后序序列），就能重建出二叉树了。

![表达式栈及二叉树关系](../../pic/ds/表达式栈及二叉树关系.png)

上图展示了表达式经由栈向二叉树的转换过程。反之，通过黄色的虚线边，表达式树也可以转换回三种表达式。

在上一章里重点讨论的是后缀表达式。在这里，笔者希望您不翻阅前面的内容，回忆出后缀表达式的计算算法。

表达式树反映的是表达式的计算过程，只需要对计算算法略加修改，就得到了后缀表达式变换为表达式树的算法。

```c++
// 算法4.5 - 后缀表达式转换为表达式树
ExpressionTree::ExpressionTree(const SuffixExpression& exp) {
    Stack<BTNode<ExpressionElement>*> S;        // 构造使用的辅助栈
    exp.traverse([&](Rank, const ExpressionElement& e) -> void {
        auto v = new BTNode<ExpressionElement>(e); // 创建对应的节点
        if (e.isOperator()) {                   // 假设运算符都是双目的
            v->rc = S.pop();
            v->lc = S.pop();
        }
        S.push(v);                              // 组合成子树，push回去
    });
    _root = S.pop();                            // 最后剩下的就是整个表达式树的根
    _size = exp.size();                         // 树的规模和后缀表达式长度相等
}
```

### 表达式树的计算

利用表达式树的递归定义，很容易得到表达式树的计算算法。只需要递归地计算每棵子树（子表达式）的值，然后用根节点上的运算符计算它们，就可以得到表达式树的值。

```c++
// 算法4.6 - 表达式树的计算
int ExpressionTree::getResult() const {
    Stack<int> S;                               // 用于计算结果的辅助栈
    postorderTraverse([&](const BTNode<ExpressionElement>* v) -> void {
        if (v->value.isNumber()) {
            S.push(v->value.getNumber());       // 如果是运算数，直接加入到栈中
        } else {
            int opCount = v->value.operationNumberCount();
            S.push(v->value.apply(Vector<int>(opCount, opCount, [&](int) -> int {
                return S.pop();
            })));                               // 否则取元素计算之后压回栈
        }
    });
    return S.pop();
}
```

在考试中，表达式的问题通常形式是：给出一个后缀表达式（或表达式树），让您求取它的值。对于表达式树，只需要在纸面上执行递归计算即可（并不需要实际使用栈，因为可以把每棵子树的计算结果标记在它的树根旁边）。因为每一步计算对应树的一个内部节点，所以非常适合<u>检查计算是否正确</u>。

> 您已经在**算法4.5**中发现，后缀表达式转换成表达式树的过程，和后缀表达式的计算过程非常相似。所以，在您使用上一章的算法计算后缀表达式的值的同时，您可以将其转换成一棵表达式树。
>
> 随后，您可以通过对表达式树进行后序遍历，验证其和后缀表达式的等价性。并通过对表达式树再次进行计算，来对后缀表达式的计算结果进行验证。这一方法的好处是，可以利用表达式树适合检查的特点，提高做题的正确率。这是笔者建议的做法。

另一种题目是前缀、中缀、后缀表达式之间的相互转换。

> 笔者的建议是，这种问题统一将给定的表达式转换成表达式树进行处理。比如说中缀转后缀的问题，先构造表达式树，然后通过在表达式树上做中序遍历，验证和给定中缀表达式的等价性，再在表达式树上做后序遍历得到目标的后缀表达式。这一方法同样是为了方便检查、提高正确率。
>
> 在计算机中要将中缀表达式转换成表达式树，方法和**算法4.5**相似，是对中缀表达式的计算过程进行修改。但在纸笔上做这步转换并不需要这么复杂，因为中缀表达式是为人们所熟知的表达式形式，您一定已经习惯<u>总是从最高优先级的一步计算出发，而不是从左向右进行扫描</u>。比如`a+b*(c-d)`，您想要计算这个式子，一定会先从`c-d`开始，而不是从左往右地先看到`a+b`。所以，可以利用表达式树的定义，快速地将中缀表达式转换成表达式树。

### 无递归的先序遍历

**算法4.3**中介绍了递归形式的先序遍历、中序遍历和后序遍历，它们共同地基于二叉树的递归结构，具有高度的形式一致性，非常容易记忆。从这一小节开始，将陆续介绍这三种遍历的非递归形式；这里会用到上一章介绍的数据结构栈。

> 二叉树是递归定义的半线性结构，因此NLR、LNR、LRN是高度对称的，从而三种遍历的递归形式具有高度的形式一致性。
>
> 但栈是一个非递归定义的线性结构。当使用栈消除递归时，各个元素的入栈、出栈变成了线性的工作，NLR、LNR、LRN不再是对称的（位置关系发生了本质的变化），从而三种遍历的非递归形式（使用栈）在形式上具有显著的区别。
>
> 当然，您可以直观地发现NLR和LRN仍然是对称的，将NLR颠倒过来、再交换每个节点的左右子树就可以得到LRN。因此您可以预感到，在使用栈的场合，后序遍历和先序遍历仍然具有某种程度的形式一致性，这一点将在介绍无递归后序遍历的时候讨论。

这一节先讨论无递归的先序遍历。对于先序遍历来说NLR来说，递归部分`traverse(L)`和`traverse(R)`位于`visit(N)`之后，也就是函数`traverse(N)`的末尾。这是一个典型的尾递归，可以使用在上一章中介绍的模板解决。

> 如果您忘记了上一章中介绍的尾递归消除策略，可以在及时复习后，自己将**算法4.3A**改写成无递归的形式。然后和下面的示例代码对比。

```c++
// 算法4.3A1 - 先序遍历（使用栈）
template <typename T>
void BinaryTree<T>::preorderTraverseWithStack(function<void(const BTNode<T>*&)> visit) const {
    Stack<BTNode<T>*&> S;
    S.push(_root);            // 从树根开始遍历
    while (!S.empty()) {
        auto t = S.pop();     // 取出栈顶元素
        if (t != nullptr) {   // 如果非空
            visit(t);         // 则对其进行访问
            S.push(t->rc);    // 并将其左右子代依次入栈
            S.push(t->lc);    // 注意顺序是反的
        }
    }
}
```

上述算法有一定的优化空间。因为在访问一个元素`t`之后，如果它的左子代存在，下一个访问的必定是它的左子代。所以，没有必要执行将它的左子代入栈、再出栈的无效操作。在遍历到一个节点`t`时，可以沿着`lc`指针一直向下，访问沿途经过的所有左子代，然后回溯地、从深到浅地依次访问它们的右姊妹。

```c++
// 算法4.3AS2 - 先序遍历（使用栈，优化）
template <typename T>
void BinaryTree<T>::preorderTraverseWithStack2(function<void(const BTNode<T>*&)> visit) const {
    Stack<BTNode<T>*&> S;
    S.push(_root);                                         // 从树根开始遍历
    while (!S.empty()) {                                   
        for (auto t = S.pop(); t != nullptr; t = t->lc) {  // 对每个节点，沿着左子代到底
            visit(t);                                      // 访问沿途经过的节点
            S.push(t->rc);                                 // 并把右子代暂存到栈里
        }                                                  // 这样回溯时会从深到浅访问右姊妹
    }
}
```

和**算法4.3AS**相比，**算法4.3AS2**在时间和空间上都有着一定程度的优化。

> 当然，这个优化程度非常小，而且破坏了**算法4.3AS**的形式美感。从记忆的角度上，笔者还是认为**算法4.3AS**更方便记忆。引入**算法4.3AS2**，是希望从先序遍历（使用栈）自然地过渡到中序遍历（使用栈），帮助您理解下一小节的内容。

### 无递归的中序遍历

当讨论到中序遍历的时候，就不再是尾递归了。这意味着无法使用**算法4.3AS**的消除尾递归的思路，但**算法4.3AS2**的思路仍然有用。对于先序遍历，一路

### 无递归的后序遍历

### 遍历序列的直接后继

上面所有消除递归的讨论中，都没有用到`parent`这个指针。这是为了让这些算法在使用“子代表示法”的、没有`parent`指针的二叉树上也食用。接下来引入`parent`指针，从另一个角度研究二叉树遍历的非递归形式：

<u>如何找到一个节点在先序/中序/后序序列上的直接后继？</u>

您已经知道，先序序列的第一个元素是树根，中序序列的第一个元素是树根一路向左下试探的终点，后序序列的第一个元素是树根一路向左、无左则右试探的终点。

所以，只要能非递归地通过一个节点`v`找到它在遍历序列上的直接后继`succ(v)`，就可以从第一个元素出发、不断调用`succ`完成遍历了。

这一节首先讨论先序的直接后继。借助**算法4.3AS2**的思路，可以得到`succ`的确定方法。

1. 如果`v`有子代，则`succ`为其子代（左子优先）。
2. 如果`v`无子代，则沿`parent`指针向上回溯，途中如果有右姊妹，则`succ`为右姊妹。
3. 如果回溯到树根`root`仍没有右姊妹，则先序遍历结束。没有后继。

```c++

template<typename T>
BTNode<T>* BinaryTree<T>::preorderSucc(BTNode<T>* p) const {
    if (p->lc != nullptr) { return p->lc; } // 有左子取左子
    if (p->rc != nullptr) { return p->rc; } // 无左有右取右子
    while (p->parent != nullptr) {
        if (p->isLeftChild() && p->parent->rc != nullptr) {
            return p->parent->rc;           // 有右姊妹则取右姊妹
        } else {
            p = p->parent;                  // 无右姊妹继续向上回溯
        }
    }
    return nullptr;                         // 回溯到树根仍然没有右姊妹，结束
}
```

仿照这个思路，您可以自己讨论先序序列的直接前驱如何求取，以及中序、后序序列的直接前驱、后继如何求取。

> 在配套代码中有示例。

### 利用直接后继进行遍历

下面使用先序序列的直接后继`preorderSucc`作为跳板，构造一个新的、无递归的先序遍历算法。

```c++
// 算法4.3AL - 先序遍历（使用后继方法）
template <typename T>
void BinaryTree<T>::preorderTraverseWithSucc(function<void(const BTNode<T>*&)> visit) const {
    for (auto p = _root; p != nullptr; p = preorderSucc(p)) {
        visit(p);
    }
}
```

下面需要证明，**算法4.3AL**和之前介绍的递归及迭代的遍历方法一样，时间复杂度都是$\Theta(n)$​。

> 对树根`r`，假设`deg(r) = 2`（其他情况更简单）。
>
> 首先，因为遍历从`r`开始、（回溯）到`r`结束，所以从子代返回`r`的次数，不会多于从`r`进入子代的次数。
>
> 因为只有遍历`r`的时候会从`r`到`r->lc`，所以左子树只被进入`1`次。
>
> 又因为只有从左子树回溯、转向右姊妹的时候会从`r`到`r->rc`，所以右子树也只被进入`1`次。
>
> 这样，`succ`对二叉树的计算就递归地变成了对左右子树各`1`次计算，以及$O(1)$的对根节点的计算。递归边界是$O(1)$的平凡树。
>
> 从而可以得到**算法4.3AL**的时间复杂度为$\Theta(n)$​​​​​​。同时也能得到，<u>在一次先序遍历的过程中</u>，**算法**的分摊时间复杂度为$O(1)$​；或称，<u>对二叉树上的每一个节点</u>，**算法**的平均时间复杂度为$O(1)$​​​。这里您可以体会并回顾一下分摊复杂度和平均复杂度的区别。

空间复杂度的问题上，**算法4.3AL**的空间复杂度是$O(1)$​，看上去比递归或用栈迭代的版本要小。但实际上，保存`parent`指针本身需要$\Theta(n)$​​的空间；从这个角度看，空间并没有被节约。

> 对于中序序列、后序序列的情况，证明方法类似，您可以自己尝试。

### 线索二叉树

在二叉树中，只有度为2的节点的子代指针是被充分利用的，度为0或1的节点，它们有的子代指针指向`nullptr`，这些指针可以被利用起来，指示该节点在某种遍历序列中的直接前驱（`lc`）和直接后继（`rc`）。

因为规模为`n`的树中有`2n`个子代指针，而只有`n-1`条边，所以有`n+1`个子代指针是空闲的。这种对空闲指针的重用称为二叉树的**线索化**（Thread），线索化之后的二叉树称为**线索二叉树**（Threaded BT）。线索二叉树的节点中需要两个额外的标志字段来告诉用户，它的`lc`和`rc`指针指向的是子代还是线索。

在画线索二叉树的时候，用实线表示子代指针，用虚线表示线索指针，并用箭头表示线索指针的方向。下面展示了一棵二叉树转换成（从左到右依次）先序、中序、后序线索二叉树的例子。

### 二叉树的线索化

### 层次遍历

在本节的最后，介绍另一种遍历方式：**层次遍历**。

层次遍历和先序、中序、后序遍历都不同，且考到的可能性较低，所以放在最后介绍它。之前介绍的三种遍历（包括没有展开的NRL、RNL、RLN），都是基于递归的思想的，<u>在遍历的时候保持了树的拓扑结构</u>，位于同一子树的节点，在遍历时访问次序也靠近。而层次遍历从普通人的角度看更为直观：就是从上到下遍历每一层，在每一层从左到右访问每个节点。

<u>层次遍历会破坏树的拓扑结构</u>，所以，层次遍历的相关问题几乎无法使用递归的手段进行分析。但另一方面，层次遍历能保持遍历时访问深度的单调性，分析时往往从这个角度入手。

层次遍历先上后下、先左后右的特点和先序遍历是一样的。区别在于，对层次遍历而言，在访问第`k`层的时候，第`k-1`及更高的层必须全部访问完毕。所以，层次遍历需要使用*队列*代替先序遍历中的*栈*。

对**算法4.3AS**进行很小的修改，就可以得到层次遍历的算法。

```c++
// 算法 - 层次遍历
template <typename T>
void BinaryTree<T>::levelTraverse(function<void(const BTNode<T>*&)> visit) const {
    Queue<BTNode<T>*&> Q;
    Q.enqueue(_root);         // 从树根开始遍历
    while (!Q.empty()) {
        auto f = Q.dequeue(); // 取出队列中的队首元素
        if (f != nullptr) {   // 如果非空
            visit(f);         // 则对其进行访问
            Q.enqueue(f->lc); // 并将其左右子代依次入队
            Q.enqueue(f->rc);
        }
    }
}
```

您可以看到**算法**和**算法4.3AS**具有高度的形式一致性。

因为所有被加入到队列中的元素，必定是树根、或某个节点的子代，所以总共被加入到队列的元素数量为`2n+1`（`n`个节点，以及`n+1`个外部节点即`nullptr`），因此层次遍历的时间复杂度仍然为$\Theta(n)$​​​。

空间复杂度视队列的实现方法而定，如果不允许释放或重复利用已出队元素的空间，则同样是$\Theta(n)$（请您自己回忆队列的相关知识点）；允许的情形，则为$\Theta(\max\limits_{0\le i\le h} n_i)=O(n)$，其中$n_i$是第$i$层的节点数量。

> 利用<u>出队节点的深度单调不减</u>，以及<u>一个节点和它的子代至多有一个在队列中</u>，可以证明在<u>同一时刻，队列中的元素只能出现在二叉树的相邻两层</u>。从而得到上述空间复杂度结论。



