# 树与二叉树

在前两章中介绍的向量、列表、栈、队列、双端队列都属于**线性结构**，元素之间存在一个线性的次序。分块表属于**块状结构**，但块和块之间、块内部各个元素之间，仍然是线性的，所以也可以被归入**线性结构**的范畴。

这一章将介绍的**树**（tree）则是一种**半线性结构**。

> 一方面，树不是完全的线性结构，因为不是任意两个元素都有次序；
>
> 另一方面，树也不是完全的非线性结构，因为也不是任意两个元素，都不能比较次序，并且在规定了一定的约束条件的前提下，它可以转化成一个有线性次序的序列。

有关树的内容是整个《数据结构》学科的核心，也是考试的重点和难点所在。同时，在这一部分，清华大学的本科教学无论是知识点的数量，还是知识点的深度，都超出了统考大纲很多。

因此，笔者将半线性结构的内容拆分成了三章。本章介绍树和二叉树的基本概念，下一章介绍二叉搜索树，最后介绍树形结构的典型应用：优先队列。在《算法设计》部分，将介绍初试之外、机试可能涉及的一些树的应用。

<u>特别注明：本笔记的内容确认和邓俊辉《数据结构》的定义没有冲突，但不确认和其他的教材没有冲突。在树的部分，存在很多定义有争议的内容，请您根据您使用的教材进行甄别。</u>

## 树与二叉树的结构

这一节从数学上的树出发，逐步增加限制条件，为您展示计算机领域研究的树有何特性。

在这一节里介绍的内容是纯理论的，并不包含算法和实际的代码实现，其目的在于让您对计算机领域所研究的树有一个清楚的理解。如果您已经非常熟悉树有关的理论知识，也可以选择跳过这一节。

### 树的定义

一棵树由被称为**顶点**（vertex）的数据单元，和若干连接不同顶点的**边**（edge）组成。在计算机领域，讨论树的时候顶点通常称为**节点**或**结点**（node），就和前面介绍的列表一样。

> 计算机领域的树和数学上的树有一定的不同，在这一节将具体介绍。采用顶点还是节点的叫法，一定程度上有助于区分上下文提到的树，是指计算机领域的树，还是数学上的树。

在数学上，**树**（tree）被定义为连通无环图。您可以通过一个具体的例子理解什么是树：

![树](../../pic/ds/树.png)

在上图中，左边的黄色部分是一棵树；中间的蓝色部分因为多了一条粉色边，形成了ABCF的环，所以不是一棵树；右边的绿色部分因为少了一条边，导致D和其他顶点不连通，所以也不是一棵树。

> 一般的无环图称为**森林**（forest），森林可以看成是一棵或多棵树组成的，它不需要满足连通性。

类似前面介绍过的数据结构，将树中顶点的数量称为树的**规模**（size）。计算机领域研究的树，规模总是有限值，因此称为**有限树**。

规模为0（没有顶点也没有边）的树称为**空树**。空树和规模为1（只有1个顶点，没有边）的树合称为**平凡树**，这2种特殊情形在分析树的相关性质时经常需要单独拿出来讨论，比如作为递归边界等。

### 树的基本性质

**命题1. 树的任意两个顶点之间，有且只有1条路可以连通。**

> “有1条”由树的连通性保证。
>
> “只有1条”由树的无环性保证。

在树上，只被1条边连接的点称为**叶子**。

**命题2. 非平凡树上至少有2个叶子。**

> 设`(A, B)`是树上不经过重复顶点的最长路。
>
> > 一条路径的**长度**，等于其经过的边数。
>
> 假设`A`被不在`(A, B)`路径上的边`(A, X)`连接，那么如果`X`是`(A, B)`经过的顶点，树上就有了环，矛盾；如果`X`不是`(A, B)`经过的顶点，`(X, B)`就是一条更长的路，和`(A, B)`最长性矛盾。
>
> 因此，`A`只被1条边连接，也就是`(A, B)`路径经过的那条边。同理，`B`也只被1条边连接。因此，树上至少有2片叶子。

记树的规模为`n`，树上的边数为`m`。

**命题3. 当n > 0时，m = n - 1。**

> 递归边界是`n=1`，此时恰好有`0`条边。
>
> 对于`n>1`，由于树上至少存在一个叶子`A`，将`A`以及连接`A`的那条边从树上删去，得到的就是一棵规模`n-1`的树。递归下去即可证明规模为`n`（`n>0`）的树上恰好`n-1`条边。

上述的两个命题用到了两个重要的技巧。

1. 最值反证法。通过取一个“最大”或“最小”的情况（树的规模有限，因此最值一定存在），让反证法的假设和最值矛盾。这种方法通常用于<u>数学性质的证明</u>，因此在考试中出现的频率比较低。
2. 递降法。这个方法在前面已经多次使用，在计算机领域，这种方法的使用频率会比反证法高得多；并且，<u>因为在计算机领域的树是**递归定义的**，所以它天然具有应用递降法的背景条件</u>，在下一小节将会展开介绍这一点。

下面两个对称的命题，证明非常简单，不再赘述。

**命题4. 在树上删除任何一条边，都会破坏连通性。**

**命题5. 在树上添加任何一条边，都会破坏无环性。**

### 有根树

回到树的问题上来。上述定义的数学上的树，是不具有半线性性质的。为了让其有半线性性质，需要规定树上的一个顶点为**树根**（root）。和大自然中的树不一样，树上的任何一个节点，包括叶子，都可以当做树根。

以上一节图中的树为例，下面展示了分别以A-F为树根得到的形态：

![树根](../../pic/ds/树根.png)

在确定了树根`r`之后，对于树`T`上的其他节点`v`，定义`v`的**深度**`depth(v)`为`v`到树根`r`的唯一路径的**长度**。

比如在上面的黄色树中，`A`是树根，那么`depth(B) = 1`，而`depth(C) = 2`。特别地，树根的深度`depth(r)`定义为`0`。规定了深度之后，就可以让同一深度的顶点排在一层，画成上面这种形式的图。对于深度为`k`的顶点`v`，就称`v`位于第`k`层。

> 有些教材会定义树根在第1层而非第0层，这违反了计算机学科从0开始计数的思维方式，从而会导致后面的一些等式和不等式多出一个额外的+1项，既不美观又不方便记忆。
>
> 考研试卷上如果出现这种定义，就是出卷老师刻意想坑一手没注意到的同学，请务必注意这个额外的+1。

上图中的6个树，尽管<u>在数学角度上看是拓扑同构的</u>，但是因为<u>规定的树根不同</u>，所以<u>在计算机角度上看是不同的树</u>。这是因为，在计算机角度研究的树，总是**有根树**，即定义了树根的树。之后如无特殊说明，笔记中所说的树都是有根树。

给定树的拓扑结构，根据给定的树根画出对应的有根树，这是一项基础技能，您应该已经掌握它了。

### 节点的关系

接下来介绍关于树的其他概念。

对于任意节点`v`，在`v`通往树根`r`上的唯一路径上的所有节点，都是`v`的**祖先**（ancestor），`v`是它们的**后代**或**子孙**（descendant）。<u>一个节点总是它自身的祖先和后代</u>。自身以外的祖先（后代）称为**真祖先**或**真后代**。

显然，一个位于第`k`层的节点，它的真祖先分别在第`k-1`、`k-2`、……、`1`、`0`层，一共`k`个。将它位于第k-1层的祖先，也就是和它直接有边相连的祖先称为它的**亲代**或**亲节点**（parent）。相应地，一个节点是它的亲代的**子代**或**子节点**（child）。拥有共同亲代的节点之间互为**姊妹**（sibling）。

> 这里稍微说明一下这几个名词的选取。
>
> parent、child和sibling最常见的翻译是“**父亲**”、“**儿子**”和“**兄弟**”，这种将数据结构树当成父系亲族树的说法还有“**堂兄弟**”“**祖父**”等（定义不再赘述），笔者认为这些写法不太妥当。另一些观点激进的翻译者，会将其翻译成“**母亲**”、“**女儿**”和“**姐妹**”，笔者认为这同样不妥当。
>
> > 在英文语境下，使用father、daughter等词语的文章也很多，因为读者都知道这些词汇的意义，所以并不会影响阅读和理解。当然，随着性别平等意识的兴起，近年的英文文献已基本规范为parent、child和sibling；但国内的文章有些翻译自较为古早的英文文献，因而<u>有可能是沿用了英文原文的性别色彩，并不是翻译者采用了带有性别色彩的译法</u>。
>
> 但是，parent常见的中性化翻译“**双亲**”有严重的误导性，容易让人误认为一个节点有2个parent。这个问题比“父亲”、“母亲”更加严重。
>
> 所以，在这本笔记中使用了一个冷门翻译“**亲代**”。
>
> 对于child，常见的中性化翻译“**孩子**”没有这个问题，不过为了对应，这里采用的也是冷门翻译“**子代**”。
>
> 对于sibling，直接沿用了常见的中性化翻译“**姊妹**”。
>
> 笔者相信虽然用的词汇不同，但您都是可以理解并轻松能够转换的。
>
> 在考试试卷上以上所有译名都可能出现，您应该采用和试卷上一样的译名。如果试卷没有给出，用上面任意的译名都是可以的。

### 子树

一个节点`v`的子节点数量称为它的**度数**或**度**（degree），记作`deg(v)`。

没有子节点（度为0）的节点称为**叶节点**或**叶子**（leaf）。

> 在规定了树根的树中，叶子都采用这个定义，而不是前面那个“只和一条边相连”的数学上的定义。
>
> 这两者的区别在于，<u>有且只有一个子节点的树根在这个定义下不再是叶节点</u>。因此，对于有根树而言，只能保证<u>非空树中至少有一片叶子</u>。

叶节点以外的节点统称为**内部节点**（internal node）。

一个节点`v`的所有后代及连接这些点的边也构成一棵树（您可以使用递降法证明），称为以节点`v`为根的**子树**`subtree(v)`。

> 子树的存在，意味着树可以被**递归定义**。
>
> 1. 递归边界：平凡树。
> 2. 一共`n`棵树，
>
> 因此，树上的命题总是可以用下面的递降法证明。
>
> 1. 要证明命题对树`T`成立，只要证明对于`T`的根节点的每个子节点`v`，命题对`subtree(v)`成立。
> 2. 递归边界：命题对平凡树成立。

因为一个节点就对应了一棵子树，所以在不引起歧义的情况下，节点和子树这两个词可以互相指代。

在树`T`中，所有节点深度的最大值称为树`T`的**高度**，记作`height(T)`，特别地，规模为`0`的空树的高度为`-1`。

对于树上的任意节点`v`，称以`v`为根的子树`subtree(v)`的高度，为`v`的**高度**`height(v)`。树的高度和根节点的高度相等。

**对于树T上的任意节点v，都有`depth(v) + height(v) <= height(T)`。**

> 这个命题您可以用上述的递降法轻易证明。

如果树上的每个节点的度数都不超过1，这棵树就<u>退化成了一条链</u>。退化成链的树，每一层都只有1个节点，它常常作为“最坏情况”的例子被用来分析一些算法在最坏情况下的复杂度，在后续章节中将会看到它发挥作用的地方。

另一种常常作为“最坏情况”的例子是<u>菊花图</u>。即，除了根之外，所有的节点都是叶子，整棵树只有2层。由于在拓扑上，这种树可以被画成一个中心节点辐射出`n-1`个“花瓣”节点的形状，所以被称为菊花图。

### 二叉树与有序树

如果树上的每个节点的度数都不超过2，则称其为**二叉树**（binary tree，下面简称为BT）。

> 因为计算机是二进制的，所以二叉树相对于一般的树，更适合在计算机中进行处理和分析。在下一节，您将会看到任何一棵普通的树或者森林，都可以被转换成二叉树进行处理。

在二叉树中，每个亲节点至多有2个子节点，所以可以用左、右来区分它们。

为了让对二叉树的分析讨论更具有一般性，可以将空树纳入讨论。这样，如果一个节点只有1个子节点，如只有左子节点，则认为，它的右子树是一棵空树。如果一个节点是叶子，则认为它的左右子树都是空树。这样，就使得对于二叉树上的每一个节点，都可以定义它的左右子树。

> 从数学角度看，交换左、右子树不会影响树的拓扑结构，但在计算机中存储数据总是有先后的，不存在真正意义上的、元素地位完全对称的“集合”。所以研究的总是**有序树**。
>
> 由于有序性，下图中的各树都是不相同的树。

![有序树](../../pic/ds/有序树.png)

有序性和有根性一样，都是计算机领域的树，相对数学上的树所需要满足的特殊性质。

### 满二叉树

对于一般的二叉树而言，内部节点的度数是可以为1的，也就是说，可以只有左子代，或者只有右子代。而如果每个内部节点的度数都为2（既有左子代又有右子代），则称其为**真二叉树**（proper BT）。

如果一棵真二叉树的所有叶子节点都在最底层，则它称为**满二叉树**（full BT）。满二叉树是特殊的真二叉树。

显然，平凡树都是真二叉树，并且也都是满二叉树。从定性的角度看，满二叉树是“图形被填得最满的二叉树”；从定量的角度看，则有下面的几个命题。

**命题1. 在一棵二叉树中，深度为k的节点至多$2^k$个。**

**命题2. 一棵高度为h的二叉树至多有$2^{h+1}-1$个节点。**

**命题3. 高度为h的满二叉树恰好有$2^{h+1}-1$个节点。**

> 上述命题都可以由归纳法证明。
>
> 在考试时使用公式的时候，只需要验证空树（规模0、高度-1），就可以验证自己的记忆是否出现了偏差；如果记忆有错，当场重新推导也并不困难。理解推导方法，会用特殊情况验证，就可以大大降低公式的记忆量。
>
> 另一方面，对于考试现场计算的更加复杂的公式，常常也可以通过平凡树、链、菊花图、满二叉树等典型的结构来进行验算。

### 完全二叉树

如果一棵二叉树满足：

1. 叶子节点都分布在最底层和次底层。
2. 最底层的叶子都分布在次底层叶子的左侧。
3. 若删去最底层的叶子，则得到一棵满二叉树。

则其称为**完全二叉树**（complete BT）。

满二叉树是特殊的完全二叉树。当然，作为特殊的满二叉树，平凡树也都是完全二叉树。

可以看出，完全二叉树的定义依赖于树的有序性。为了理解完全二叉树，您可以自己画图给出反例，从而证明下面的两个命题。

**命题1. 满二叉树既是完全二叉树，又是真二叉树。但，既是完全二叉树，又是真二叉树的不一定是满二叉树。**

**命题2. 完全二叉树不一定是真二叉树，真二叉树也不一定是完全二叉树。**

一个参考的图例如下。

![完全二叉树](../../pic/ds/完全二叉树.png)

> 从左到右：
>
> 树1：满二叉树，完全二叉树，真二叉树。
>
> 树2：完全二叉树，真二叉树，但不是满二叉树。
>
> 树3：完全二叉树，但不是真二叉树。
>
> 树4：真二叉树，但不是完全二叉树。

完全二叉树可以看成是满二叉树的推广。满二叉树具有非常良好的性质，但受限于规模n只能是$2^{h+1}-1$​​​的形式，很难得到具有一般性的结果。将满二叉树推广成完全二叉树之后，仍然满足“图形被填得非常满”的特征，并且规模n可以是任意的。

由完全二叉树的定义，很显然地可以由上一小节得到的满二叉树规模公式，得到下面的**命题3**。

**命题3. 高度为h的完全二叉树，满足$2^h\le n\le 2^{h+1}-1$。**

> 左边的不等号在最下层只有一个叶子节点时满足；右边的不等号在满二叉树时满足。

此外，因为完全二叉树利用有序树的特性，规定了最下层叶子排列的位置，所以可以得到下面的**命题4**。

**命题4. 任给n，在规模为n的有序有根树中，有且只有一个是完全二叉树。**

这个命题指出，给定规模时，完全二叉树的结构是固定的。这使得当讨论完全二叉树的时候，可以不需要做结构上的分情况讨论，提供了分析上的简便。

### 带标号树

对于完全二叉树，只要给定规模n，就只存在一个满足条件的有序有根树。但是，这棵有序有根树上的节点显然是不同的数据单元。交换完全二叉树上的两个节点的位置，得到的显然是一棵新的树，尽管它的结构形态和原来的树完全一样。

> 有序树说明，同一个节点的两个子树交换位置，是两棵树。
>
> 带标号树说明，两个节点交换位置，是两棵树。

为了将不同的数据单元区分开，在有根有序树的基础上引入了标号。通常，将树上的每个节点标号为`0, 1, ..., n-1`；在各个节点存储的数据互不相同时，有时也用存储的数据为节点标号；此外，在示意图等场合，也可以用字母为部分节点标号。标号的唯一原则是<u>保证互不相同，从而可以区分不同的节点</u>。

为树上的节点做标号之后，就可以得到一棵**带标号树**。在绘制带标号树的时候，通常将标号写在代表节点的圈内。

> 到此为止，得到了计算机领域的树在数学上的定义：
>
> **树（计算机）是有根的、有序的、带标号的、有限的树。**
>
> 后文中，凡是不加指明地使用的“树”，均指**树（计算机）**。

### 根据树的性质建模

这一节中出现了很多定义，在考研的《数据结构》中，通常不会出现对于概念定义的考察，而是在理解概念的基础上，要求学生做一些简单的计算。和栈或队列要求您画图枚举不同，树相关的计算题通常数字比较大，让您列出方程或不等式求解。

方程或不等式的变量设法通常有两种，一种是按度设变量，一种是按层设变量。

> 笔者希望您掌握讨论此类题目的一般方法，而不是去记住尽可能多的结论。

**按度设变量**：在涉及度数的问题中通常采用按度设变量的方法。在二叉树中，设$n_0$​、$n_1$、$n_2$分别为度为0、1、2的节点数量（如果题目中有区分左右子代，则可以进一步将$n_1$拆分为$n_l+n_r$），就可以得到下面的限制条件：

1. $n_0­ + n_1 + n_2 = n$。（根据总节点数列出方程）

2. $n_1 + 2n_2 = n - 1$​。（根据总边数列出方程）

3. 如果是满二叉树，$n_1 = 0$且$n_0 = n_2 + 1$；

   如果是完全二叉树，$n_1 \le 1$；

   如果是真二叉树，$n_1 =0$。

**按层设变量**：在涉及高度的问题中通常采用按层设变量的方法。在二叉树中，设$n_k$​为第$k$层的节点数量（$k = 0, 1, 2, ..., h$），其中$h$​为树高（待定），就可以得到下面的限制条件：

1. $n_0 + n_1 + \dots + n_h = n$​。（根据总节点数列出方程）
2. $n_0 = 1$。（只有1个根节点，若不考虑空树的情况）
3. $1 \le n_k \le 2n_{k-1}$​。（根据二叉树性质列出不等式）如果是满二叉树，则对所有的$k$​都取等号；如果是完全二叉树，则对除$k = h$​外的$k$​都取等号。

对于一般的、非二叉的树，也可以列出类似的方程。

> 如果既涉及度数的问题，又涉及高度的问题，则可能需要将上面两种方法结合起来列出方程和不等式。

### 针对树的性质求解

下面从几个典型问题出发，应用这两种思路。

**问题1. 已知一棵完全二叉树有$l$个叶子结点，求它的总节点数。**

> 相当于在条件
> $$
> \begin{cases}
> l+n_1+n_2=n\\
> n_1+2n_2 =n-1\\
> n_1 \le 1
> \end{cases}
> $$
> 的条件下求$n$。将$n_1 = 0$和$n_1 = 1$分别代入，可以得到两个二元一次方程组，分别解之即可得$n$的两个可能值。

**问题2. 设一棵k叉树（k >= 2）的节点数为n，求它的叶子数量的取值范围。**

> 相当于在条件
> $$
> \begin{cases}
> n_0 + n_1+n_2+\dots+ n_k=n\\
> n_1+2n_2+\dots+kn_k =n-1
> \end{cases}
> $$
> 两个限制条件下，求$n_0$​的最大值和最小值。由于$n_i$​被限制为非负整数，使用Lagrange乘数法求解并不方便，应当使用不等式代换。
>
> 显然$n_0$的最小值是1（前面介绍过，有根树至少有一个叶子；并且在树退化成链的时候可以取到）。
>
> 为了让$n_0$​取最大，则$n_1 + n_2 + \dots + n_k$​应该尽可能小，而
> $$
> n_1+n_2+\dots+n_k\ge \frac 1k (n_1+2n_2+\dots+kn_k)=\frac{n-1}k
> $$
> 如果$(n-1)\%k=0$，则当$n_k = (n-1)/k$，其余为$0$时取最小；
>
> 如果$(n-1)\%k\ne 0$，则当$n_k =\lfloor                                 (n-1)/k\rfloor$  ，$n_{(n-1)\%k} = 1$，其余为$0$时取最小。

**问题3. 设一棵k叉树（k >= 2）的节点数为n，求它的高度的取值范围。**

> 相当于在条件
> $$
> \begin{cases}
> n_0+n_1+n_2+\dots+n_h=n\\
> n_0=1\\
> 1\le n_i\le kn_{i-1}
> \end{cases}
> $$
> 的限制条件下，求$h$的最大值和最小值。
>
> 最大值仍可以通过将树退化成链算出，此时$h + 1 = n$，$h_{max} = n-1$。
>
> 最小值则通过
> $$
> n = n_0 + n_1 + n_2 + ... + n_h \le 1 + k + k^2 + ... + k^h = \frac{k^{h+1}-1}{k-1}
> $$
> 可以算出，此时对应完全k叉树的情况。

另外，除了由于此类题目总是以选择题出现，所以您也可以直接取一些极端情况来快速得到答案。常用的极端情况包括完全k叉树、退化成链、菊花图和双链（向一个方向延伸的链，叶子作为另一个方向的子代挂在链上）。

## 二叉树的遍历

