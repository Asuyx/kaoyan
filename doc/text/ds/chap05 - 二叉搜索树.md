# 二叉搜索树

在计算机领域，数据结构的有序性常常能够给查找带来便利。正如您之前所看到的，在无序向量中查找需要$O(n)$的时间，但在有序向量中只需要$O(\log n)$。同样地，无论采用何种遍历方式，在“无序”的二叉树中要查找一个元素，也需要$O(n)$的时间。为了让这一时间复杂度得到降低，就必须让二叉树也服从某种“有序”的性质，使其变为**二叉搜索树**（Binary Search Tree，以下简称BST，也有一些教材译作**二叉排序树**或**二叉查找树**）。

## 二叉搜索树

这一节介绍普通的、没有限制条件的二叉搜索树，为后续的几节提供一个基础的模板。

### 二叉搜索树的定义

有序性是一种线性的性质，因此它必然和BST的某一种线性化序列有关。在4种遍历方法中，<u>中序遍历</u>的性质是最优的。因此，BST可定义为：<u>中序序列有序（单调不减）的二叉树</u>。

> 这里的有序性要求二叉树节点上的标号的集合上，可以定义全序关系“$\le$”。

选择中序序列的原因，可以从两方面进行理解。

第一个方面从设计递归算法的角度去理解（查找的角度、静态理解）。

> 首先，为了能够进行递归算法，肯定可以排除掉层次遍历。接下来比较先序、中序和后序遍历。
>
> 在查找的过程中，总是从二叉树的入口，也就是根节点开始，但在先序和后序遍历中，根节点要么在最左边，要么在最右边。以先序遍历为例，如果比较下来根节点小于待查找元素`e`，那么`e`会出现在左子代还是右子代并不能得知，因此两棵子树都需要继续探测。
>
> 结果就是经典的$T(n) = 1 + T(n-k) + T(k)$，解出$T(n) =\Theta                                 (n)$，相对于无序的二叉树没有提升。
>
> 而中序遍历则不然，如果`r`小于`e`，那么在中序序列上，位于树根`r`之前的整棵左子树都必定小于`e`，也就是说没有必要再向左子树搜索了。那么，如果树根`r`在中序序列的中央附近，就可以实现类似于有序向量的折半查找的功效。

第二个方面是从增强序列的角度理解（更新的角度、动态理解）。

> 在中序遍历的增强序列上，每个元素的直接前驱和直接后继都是外部节点。这意味着任何一个节点都很容易被调整到叶子。在二叉树上，针对叶子的操作容易完成，且不会对树的拓扑结构有很大的影响。
>
> 但在其他3种遍历中，增强序列的外部节点位置是游移不定的（仅受栈操作序列的约束），很难将一个节点调整到叶子。针对内部节点的操作难度很大。
>
> 因此，为了让BST能够动态地维护一个有序序列，降低插入、删除元素的成本，也应该选择中序序列。

### 二叉搜索树的查找

上一小节已经讨论过，二叉搜索树的查找和有序向量折半查找是相似的，您可以自己写出它的递归版本和迭代版本。下面直接给出已经消除尾递归的代码。

```c++
// 算法5.1
template <typename T>
BTNode<T>* BinarySearchTree<T>::find(T e) const {
    BTNode<T>* pos = root();            // 从树根开始查找
    while (pos != nullptr) { 
        if (pos->value == e) { break; } // 查找成功
        if (cmp(pos->value, e)) {       // 根据大小关系决定查找方向
            pos = pos->rc;
        } else {
            pos = pos->lc;
        }
    }
    return pos;
}
```

在这个算法中，每进入一次循环会进入高度减1的子树，因此最坏时间复杂度为$\Theta(h)$。高度最小（如完全二叉树）时$h=\Theta(\log n)$，**算法5.1**可以达到和有序向量折半查找一样的$\Theta(\log n)$最坏时间复杂度。而高度最大（如退化成链）时$h=\Theta(n)$，**算法5.1**只能具有和无序向量顺序查找一样的$\Theta(n)$最坏时间复杂度。

> 您可以构造适当的二叉树结构，使得**算法5.1**的判定树和有序向量的折半查找完全一致。
>
> 另一方面，左链或者右链的情形，**算法5.1**会直接退化成和无序向量的顺序查找完全一致。

为了防止树退化成链，通常会对BST的拓扑结构作出一些进一步的限制，形成更为复杂的数据结构，这些内容将在后面几节详细展开。

> 注意到，如果BST上有多个节点和元素`e`相等，上述算法返回的是深度最低的节点（请您尝试证明，深度最低的节点只有一个）。您可以自行改写该算法，使得当BST上有多个节点和元素`e`相等时，返回其中在中序序列上位置最前或最后的节点，从而实现和之前所介绍的有序向量折半查找一致的语义。

### 二叉搜索树的批量查找

### 二叉搜索树的插入

### 拓展：随机二叉树

为了用$n$来表示平均意义下的时间复杂度$\Theta(h)$，首先需要弄清楚“平均”如何定义。在BST的问题上，有两种方法可以定义“平均”。

1. **随机生成二叉树**。以随机的顺序（$n!$种等概率的可能）插入`n`个节点得到的BST。

   可以通过$\Theta(n)$的时间执行**算法2.8**（随机生成排列），再通过平均$\Theta(n\log n)$的时间依次执行`n`次**算法5.3**，得到BST。

   > 这种情况下，平均树高是$\Theta(\log n)$的。证明可参见《算法导论》第12.4节（证明较为复杂，有兴趣可自行阅读）。

2. **随机组成二叉树**。随机选取一种二叉树形态（$\mathrm{Catalan}(n)$种等概率的可能）按中序标号得到的BST。

   可以通过$\Theta(n)$的时间执行**算法3.6**（随机生成栈操作序列），再通过$\Theta(n)$的时间转换成二叉树（参考增强序列对二叉树的重建，类似**算法4.5**），最后再通过$\Theta(n)$的时间执行中序遍历进行标号，得到BST。

   > 这种情况下，平均树高是$\Theta(\sqrt{n})$的。证明可参见论文《The average height of planted plane trees》（证明非常复杂，无数学基础不建议阅读）。

上述两个平均树高结论由于证明过程复杂，可以直接记忆。

这一小节补充介绍一种直接构造随机组成二叉树的算法（**Rémy算法**），不需要借助栈操作序列做跳板。

>  朴素的随机组成思路可以分成四步：栈操作序列→先/后序增强序列→二叉树→标号二叉树（BST）。
>
> Rémy算法直接从增强序列和二叉树的联系入手。当讨论到增强序列时，会在二叉树上补充`n+1`个外部节点，使其变成增强的二叉树。增强的二叉树和二叉树之间是有无外部节点的关系，其映射是一一的，因此`n`阶（`2n+1`个节点）增强的二叉树和`n`阶二叉树的数量一样，都是$\mathrm{Catalan}(n)$。
>
> 所以，直接生成增强的二叉树，同样是$\mathrm{Catalan}(n)$种可能，并不能有效地绕过栈操作序列。

Rémy注意到，<u>可以给增强的二叉树上的外部节点标号</u>。外部节点被标号的增强的二叉树称为**装饰树**（decorated tree）。那么，`n`阶装饰树的数量为$D_n =(n+1)!\cdot \mathrm{Catalan}(n)=(2n)!/n! $。

故可以得到$D_n = (4n-2)D_{n-1}$。这就比$\mathrm{Catalan}(n)$的前后项关系友好很多（比例是一个整数），接下来就可以用递归的思路去生成`n`阶的装饰树了。

> 对于`n`阶的装饰树（`2n+1`个节点，外部节点标号为`[0:n]`），它比`n-1`阶的装饰树多一个内部节点和一个外部节点。那么，删去标号为`n-1`的外部节点`x`，及内部节点`y = x->parent`（用`x`的姊妹`z`代替`y`）就可以得到一个`n-1`阶的装饰树。
>
> 反过来，如果已经生成了`n-1`阶装饰树，那么，先等概率地随机选择树上的一个节点`z`（`2n-1`种可能），然后用节点`y`代替`z`，子树`z`作为`y`的左子树或右子树（等概率选取，`2`种可能），`y`的另一个子代的位置上，挂载标号为`n-1`的外部节点`x`。
>
> 上述从`n-1`阶装饰树推出`n`阶装饰树的过程，恰好包含`4n-2`种等概率的可能，与$D_n = (4n-2)D_{n-1}$相对应。

以上递归的过程可以由下图表示。

### 二叉搜索树的删除

