# 算法及其评价

本章是《数据结构》的第一章。这一章将从算法的定义和评价出发，重点介绍在《数据结构》学科中最为重要的思维方法：**递归**（recursion）。这一思维方法的建立为《数据结构》后续知识点的理解和掌握打下了基础。

## 算法的定义和评价

> 我们想事情，做工作，想得对不对，做得好不好，要有一个根本的衡量尺度，这就是人民拥护不拥护，人民赞成不赞成，人民高兴不高兴，人民答应不答应。
>
> ——Chairman Jiang

### 概念和定义的争议

**算法** （algorithm）是计算机领域的核心概念之一。和更加核心的概念“**计算机** （computer）”一样，它没有一个被广泛承认的规范定义。一些教材会把算盘甚至算筹划归“计算机”的范畴，并把手工算法（如尺规作图，甚至按照菜谱烹饪食物）划归“算法”的范畴；而另一些教材仅仅承认现代电子计算机为“计算机”，并把“算法”限定可以在图灵机上通过有限步骤执行的计算方法。

这种**概念和定义的争议**在计算机领域广泛存在，它主要来自以下几个原因（下文中提到的概念，将在后续章节中展开介绍）。

1. <u>为了叙述简便，有些概念会借用一个已经存在的专有名词，从而引发歧义</u>。如“**树** （tree）”这个词在计算机领域就有常用但迥然不同的两个概念。图论中的“树”出现得比较早，但没有人愿意将工程界经常出现的“树”称为“有限有根有序有标号的树”——英文里这些词并不能缩写为“四有树”。
2. <u>不同科学家互相不服气，都认为自己提出的定义更有优越性，从而引发歧义</u>。这个现象的典型例子是“计数时从0开始还是从1开始”。从0开始是有一定数学上的优越性的，可以避免一些公式出现刻意的“+1”余项；但从1开始计数更符合自然习惯。这个问题直接导致在有些问题（如“树的高度”）上，国内不同高校的教材采用的说法互不相同，从而引起一些学生在准备考研时感到困惑。
3. <u>随着计算机领域的快速发展，一些概念的含义会发生变化</u>。如众所周知，“**字节** （byte）”表示8个二进制位；但在远古时代，不同计算机采用的“字节”定义互不相同，有些计算机甚至是十进制的，那个时候一个字节可能表示2个十进制位。
4. <u>受计算机科学家的意识形态影响，同一概念的用词有所不同</u>。如“树上的前驱和后继节点”这一概念，现在普遍使用的词是parent和child；然而思想老旧的人可能还在用father和son，进步主义者则可能会用mother和daughter。
5. <u>计算机领域的大多数成果出自美国，而英语翻译为汉语时，不同译者可能采用不同的译法</u>。如robustness有音译的“**鲁棒性** ”和意译的“**稳健性** ”，hash有音译的“**哈希** ”和意译的“**散列** ”。
6. <u>计算机相关企业为了销售产品或取得投资，存在滥用、炒作部分计算机概念的情况</u>。如“人工智能”“大数据”“云计算”“区块链”等概念是这个现象的重灾区。不过，这些问题概念和考研复习关系不大。

由于以上这种种原因，计算机领域的很多概念都不存在“标准”、“权威”的定义，而是存在争议的。<u>清华大学的考试在争议问题上都会特别标注</u>（如“注：空树的高度认为是-1。”）。其他学校不一定会这样做，因此请务必购买您的目标高校使用的教材；如果教材和您使用的考研辅导书冲突，则需要特别注意。

### 算法定义的四个要素

回到算法的问题上来。在本笔记中，笔者采用“限定词+中心语”的方式定义“**算法** （algorithm）”，而不采用较难理解的数学定义。该定义出自*The Art of Computer Programming Vol 1, 3^rd^ Edition* （Donald E. Knuth，1997）。

> **算法** （algorithm）是<u>对于给定的输入，通过有限的、可行的步骤可以得到确定的、满足预期条件的输出结果的计算方法</u>。

这一定义规定了算法的4个要素：**有限性、可行性、确定性、有输出** 。

值得一提的是，“有输入”这个要素在这个定义中是**可选的**（optional）。这一定义认为形如“找到所有int范围内的素数”就是没有输入的算法。但相对地，“有输出”则是**必需的**，否则算法就失去了存在的意义。

根据上述定义，下面这些都不能成为算法：

1. 计算圆周率的十进制小数形式。（无法在有限步骤内完成）
2. 如果哥德巴赫猜想正确，输出1，否则输出0。（在当前阶段，*不满足可行性*）
3. 输入两个整数a和b，输出a除以b的余数。（*不满足确定性*，因为在b为0的情况下除法没有定义）
4. 读取一个文件。（*没有输出*）

### 在算法设计题中使用定义

*试卷上并不会让您判断一个计算方法是否为算法，因此背诵定义看上去并没有什么用*。这一定义是帮助您完成其他类型的题目的。

在《数据结构》考试中，关于算法最多的是**评价题**，通常有且只有一道的是**设计题**；您在复试的机试中还会面对若干道算法**上机设计题**。理解上述定义，有助于让您在设计算法后“四省吾身”：

1. <u>是否必定能结束</u>？如果您使用了`while (true)`或者`for(;;)`这样的无限循环，或使用了`goto`强制跳转，则存在不满足有限性的潜在风险。
2. <u>是否有语法错误</u>？在初试中，算法设计题的答案通常以伪代码或代码给出。语法错误不一定会被扣分，但**语义歧义**一定会被扣分。
3. <u>是否被正确定义</u>？除以0、空指针、下标越界等问题，都可能是被意外扣分的导火索。在机试中，甚至可能被有针对地设计的测试数据“重点打击”，使您失去大半甚至全部分数。
4. <u>是否有输出结果</u>？对于常见的数据结构维护类题目，数据结构本身就是输出结果，不需要再额外做输出。另一些题目则可能需要输出；尤其在机试时，您可能会忘记某个特殊分支的输出。

### 算法的评价维度

作为一种解决问题的方法，算法的评价是多尺度的，它们构成了算法题的另一种题型。即使是在算法设计题中，也经常有“对设计的算法进行评价”的附加要求。

1. **正确性**。**正确性检验**通常分为两个方面：**有限性检验**和**结果正确性检验** 。

   1. **有限性检验** 。即判定带有无限循环或强制跳转的算法是否必定能终止。没有无限循环或强制跳转的情况，有限性是默认的。
   
   2. **结果正确性检验** 。即验证输出的结果满足算法的需求。在算法有确定的正确结果时，这一检验是“非黑即白”的；而在算法没有确定的正确结果时，可能需要专用的检验程序甚至人工打分（比如较早的象棋AI，往往是以高手对一些局面的形势打分作为基础训练数据的）。
   
      *作为四要素中的另外两项：**可行性**是否成立往往一眼便知；而**确定性**如果不是一眼便知，则往能蕴含在其他两项检验当中。证明可以<u>通过有限步得到正确结果</u>，实际上也就证明了<u>在此期间不存在未定义行为</u>。*
   
2. **效率** 。评价算法效率的标准可以简单概括为“<u>多、快、好、省</u>”。在《数据结构》学科中通常只研究“快”和“省”这2个方面，到《网络原理》部分再展开来讨论全部的4个方面。

   1. **时间效率（快）** 。在计算机上运行算法一定会消耗时间，时间效率高的算法消耗的时间比较短。

   2. **空间效率（省）** 。在计算机上运行算法一定会消耗空间（硬件资源），空间效率高的算法消耗的硬件资源比较少。

      然而，在不同的计算机、不同的操作系统、不同的编程语言实现下，同一算法消耗的时间和空间可能大相径庭。为了抵消这些变量对算法效率评价的干扰作用，在《数据结构》这门学科里进行算法评价时，往往不那么注重真实的时间、空间消耗，而倾向于做**复杂度分析** 。关于复杂度的讨论参见后文。

3. **稳健性** （robustness，又译健壮性、鲁棒性；在看到英文之前，笔者曾一度认为“鲁棒性”这个词来源于山东大汉身体棒的地域刻板印象……）。即算法面对意料之外的输入的能力。
4. **可重用性** 。即算法是否能很方便地用于设计目的之外的其他场合。

在上述4个评价尺度中，<u>正确性和效率是《数据结构》学科研究的主要内容，算法评价题也总是围绕正确性检验和复杂度分析命题</u>；这两个问题留到下一节展开讨论。而稳健性和可重用性，则在课程设置上属于《软件工程》讨论的内容；作为考研复习笔记不再详述。

### 算法的具体实现形式：程序

由于后两个问题更偏向工程而非理论，这两个评价尺度更多地是和**算法的具体实现形式**而不是**算法本身**高度相关。*初学者很容易将算法和算法的具体实现形式混淆*。

算法的具体实现形式是依赖于具体的计算机、操作系统、编程语言的具体的**程序** （program）。对程序的分析和对算法的分析有着基础上的差异，下面的例子中可以看出这一点。

```c++
// 问题1.1 - 从1加到n
// 输入：正整数n
// 输出：1 + 2 + ... + n的和
```

Gauss小时候就得到了这个问题的一般公式，您很容易得到下面的算法。

```c++
// 算法1.1
// 1. 输入正整数n
// 2. 计算A = n*(n+1)/2
// 3. 输出结果A
```

根据这一算法，您可以编写出下面的程序：

```c++
// 算法1.1A
int f1(int n) {
    return n*(n+1)/2;
}
```

由于这个**算法**的正确性十分显然，以至于您或许觉得这个**程序**也毫无问题。直到您看到了另一个程序：

```c++
// 算法1.1B
int f2(int n) {
    return n % 2 == 1 ? (n+1)/2*n : n/2*(n+1);
}
```

您大概立刻意识到了**算法1.1A**存在的问题：对于某一区间内的`n`，`n*(n+1)/2`的和不会超过`max_int`的值，但`n*(n+1)`会超过这个值。比如，当`n`取`50000`的时候，**算法1.1B**能够输出正确的结果，而**算法1.1A**则会因为数据溢出而输出一个负数。您可以很容易算出这个“**算法1.1B**结果正确而**算法1.1A**不正确”的区间。

但**算法1.1B**也很难称之为无可挑剔。因为如果`n`更大一些，比如取`100000`，它也无法输出一个正确的值。

所以是**算法1.1**不正确吗？显然不是，Gauss已经证明了它的正确性。**算法1.1A**和**算法1.1B**不能对所有输入的`int`型数据得到正确的结果，这是因为`int`有数据范围限制。但是，世界上并不存在无数据范围限制的计算机（因为一台计算机上的硬件资源必定是有限的），所以如果溢出算是一种“错误”，就不会存在“正确”的算法了。

那么，是否有必要为输入的数据`n`增加一个范围限制，来保证**算法1.1**的正确？事实上这个范围限制很难设计。

其原因在于，<u>算法必须是独立于计算机的</u>。现在`max_int`当然是`2147483647`，但是在古代的16位计算机上，这个值有可能是`65536`（ANSI C标准只规定了`int`至少16位）。此外，在C++里整型数据有显式的上界`max_int`，但在另一些支持`BigInteger`的语言（如Java）中，整数是没有显式的上界的，其实际上界和计算机的空闲存储空间相关，这在每一台计算机上几乎都是不一样的。

如果一定要评价**算法1.1**的不足，只能说它在**稳健性**上有所欠缺：<u>现代计算机处理溢出数据是截断的</u>，所以当`n*(n+1)/2`的超出`int`范围时，它可能会输出一个负数。

为了提高稳健性，更好的算法可能会让`n*(n+1)/2`的和超出`int`范围时输出`max_int`，以表示“这个结果很大”。事实上，有些古代计算机在设计时就让“超出`int`范围时，整形成`max_int`”；但这样设计硬件或指令集是得不偿失的，在《组成原理》中您会看到这一点。

在《数据结构》这门学科中，您可以认为**算法1.1**是一个毫无疑问的好算法。它已有Gauss证明是正确的，并且在时间和空间上都效率很高。

## 正确性检验

> 伟大、光荣、正确的中国共产党万岁！
> 伟大、光荣、英雄的中国人民万岁！
>
> ——Chairman Xi

在上一节已经说明，**正确性检验**可以拆解为两个方面：**有限性检验**和**结果正确性检验**。试卷中会出现的题目，输出结果往往有唯一正确的“标准答案”，所以这两项检验往往可以一并完成，即检验算法是否能<u>在有限时间内输出正确结果</u>。

解决正确性检验的一般方法是**递降法**。它的思想基础是在计算机领域至关重要、并且是《数据结构》学科核心的**递归思维方法**；它的理论依据则是作为在整数公理系统中举足轻重的**数学归纳法**。

在本节中，将从数学归纳法的角度出发介绍递降法的原理，这部分有助于让您对递归思维有更加深刻的理解。当然在实际考试中只要会用递降法解题即可，您也可以跳过数学的部分。

### 经典归纳和经典递降

在高中理科数学中介绍了数学归纳法的经典形式。由于各省教材不同，您可能接触到过两种表述不太一样的数学归纳法：
$$
\mathbf{定理（第一归纳法）}\\
\begin{align}
&令P(n)是一个关于正整数n的命题。要证明P(n)对一切正整数n为真，只需要证明：\\
&1. P(1)为真。\\
&2. 对一切k\ge1，如果P(k)为真，那么P(k+1)也为真。
\end{align}
$$

$$
\mathbf{定理（第二归纳法）}\\
\begin{align}
&令P(n)是一个关于正整数n的命题。要证明P(n)对一切正整数n为真，只需要证明：\\
&1. P(1)为真。\\
&2. 如果对k<n，P(k)都为真，那么P(n)也为真。
\end{align}
$$

其中，第一归纳法是Piano公理体系的一部分，您可以很轻松地用第一归纳法推导出第二归纳法。另一方面，第二归纳法的**归纳假设**——$\forall k < n,P(k) \mathrm{\space is\space true}$，显然比第一归纳法更强；所以在实际应用数学归纳法进行证明时，通常都使用第二归纳法，而不使用第一归纳法。

> 在上面的表述中，归纳的过程是从1开始的，这比较符合数学研究者的工作习惯。
>
> 在计算机领域，归纳法常常从0开始（有时甚至从-1开始）。显然，这并不影响它的正确性。本节后续对“正整数”相关问题的讨论，一般替换成“自然数”也同样可用。

下文将第二归纳法称为**经典归纳法**。经典归纳法可以用来处理<u>有关正整数的命题</u>。相应地，对于<u>输入是正整数的算法</u>，可以使用与经典归纳法相对应的**经典递降法**。
$$
\mathbf{定理（经典递降法）}\\
\begin{align}
&设算法A(n)的输入数据n为正整数。要证明A(n)对一切正整数n都可以在有限时间内输出正确结果，只需要证明：\\
&1.	A(1)可以在有限时间内输出正确结果。\\
&2.	对于每个n > 1，A(n)可以在有限时间内将问题化归为A(k)，其中k < n。且在A(k)结果正确时，得到的A(n)也正确。
\end{align}
$$

> 经典递降法的正确性由经典归纳法保证。

显然，经典递降法的应用范围非常狭小：只能用来处理输入是正整数的算法。对于实际的算法，它的输入数据通常是多个数、乃至于数组和各种数据结构，而非孤零零的一个正整数。因此，需要对经典归纳法进行推广，从而使其可以应用到更广的范围中，并使其相对应的递降法能够处理更加多样的输入数据。

### 带映射的归纳和递降

在《线性代数》的第一章“行列式”中，您一定见过下面这个经典的命题：
$$
\mathbf{定理（Vendermonde行列式）}\\
D_n=\left|\begin{matrix}
1&1&\cdots&1\\
x_1&x_2&\cdots&x_n\\
\vdots&\vdots&&\vdots\\
x_1^{n-1}&x_2^{n-2}&\cdots &x_{n}^{n-1}
\end{matrix}\right|
=\prod_{1\le j<i\le n}(x_i-x_j)
$$
通常这个命题都是用数学归纳法证明的，您不会有任何违和感。

但在这个命题中，$n$并不是唯一的变量。在$n$之外，还有$x_1,x_2,\cdots,x_n$这$n$个变量。换句话说，这个命题所接受的是一个<u>任意有限长的向量</u>$(x_1,x_2,\cdots,x_n)$。在使用数学归纳法进行证明时，实际上指定了一个映射$f(x_1,x_2,\cdots,x_n)=n$，<u>输入数据是这个映射的原象，而在这个映射的象上做数学归纳法</u>。有些数学书为了指明这一点，会在证明的开头写上“对行列式的阶数$n$做归纳”；而有些书则图省事略去了这句话。

在这个例子中，通过“对行列式的阶数做归纳”，<u>将复杂的输入数据映射到了正整数集</u>，这是一种典型的应用归纳法的技术。类似地，<u>在证明对整数的命题时，可以对它的绝对值做归纳</u>，等等。

一般而言，可以将经典归纳法改写成下面的“带映射的”形式：
$$
\mathbf{定理（带映射的经典归纳法）}\\
\begin{align}
&令P(x)是一个关于x\in X的命题；映射f:X\to N^+是满射。\\
&要证明P(x)对一切x\in X为真，只需要证明：\\
&1. 当f(x_0) =1时，P(x_0)为真。\\
&2. 如果对f(y)<f(x)，P(y)都为真，那么P(x)也为真。
\end{align}
$$

> 可以对命题$Q(n)=P(\mathrm{全部的}f^{-1}(n))$使用经典归纳法，从而证明带映射的经典归纳法成立。

相应地，存在带映射的经典递降法。
$$
\mathbf{定理（带映射的经典递降法）}\\
\begin{align}
&设算法A(x)的输入数据x\in X；映射f:X\to N^+是满射。\\
&要证明A(x)对一切x\in X都可以在有限时间内输出正确结果，只需要证明：\\
&1.	当f(x_0) =1时，A(x_0)可以在有限时间内输出正确结果。\\
&2.	对于每个f(x) > 1，A(x)可以在有限时间内将问题化归为A(y)，其中f(y) < f(x)。\\
&且在A(y)结果正确时，得到的A(x)也正确。
\end{align}
$$
为了让上述定义的$Q(n)$总是存在，$f$需要保证是满射。这又是一项对递降法应用范围的限制，需要想办法清除掉它，得到更加一般的、更加通用的解题方法。

### 良序关系

在带映射的归纳法中，需要通过满射将定义域$X$映射到正整数集$N^+$上。很多时候，这样的满射并不容易构造。与其试图用高超的技巧去构造满射，不如从正整数集$N^+$入手：放宽映射的象的条件，不要求它一定是$N^+$，只需要满足一些和$N^+$相似的性质即可。

对于一般的集合，引入**良序**（well-ordering）的概念：
$$
\mathbf{定义（良序关系）}\\
\begin{align}
&如果集合S上的一个关系≺满足：\\
&	1.（\mathbf{传递性}）如果x≺y且y≺z，那么x≺z。\\
&	2.（\mathbf{归中性}）如果x≺y、y≺x均不成立，那么x=y。\\
&	3.（\mathbf{最小值}）对于集合S的任意非空子集A，存在最小值min⁡A=x。（即对于A中的其他元素y，总有x≺y）\\
&那么称≺是S上的一个\mathbf{良序关系}，同时称S为\mathbf{良序集}。
\end{align}
$$
根据上述定义，熟知的小于关系“<”在正整数集$N^+$上是良序的，而在整数集$Z$上不是良序的。当然，可以通过定义“绝对值小于”让整数集$Z$成为良序集。同时，熟知的小于关系“<”在非负实数集$R^+\cup\{0\}$上不是良序的，因为它不满足最小值条件。

和熟知的正整数集$N^+$相比，一般的良序集具有下面的相似性质：
$$
\mathbf{定理（无穷递降）}\\
在良序集S中，不存在无穷序列\{x_n\}，使x_{j+1} ≺ x_{j}对一切j成立。
$$
这一性质使得在一般的良序集上做归纳法成为可能，后面的小节会回到这个问题上来。

### 字典序

在上一小节，您发现熟知的小于关系在非负实数集$R^+\cup \{0\}$上并不是良序的。如果您感到不服气，想要尝试去构造$R$上的良序关系，几乎一定会无功而返（目前还没有数学家定义出实数集$R$上的显式良序关系）。然而：

> **良序定理**：（ZFC）任何集合都存在良序关系。

在集合论的**ZFC公理体系**下，上述定理成立。在**ZF公理体系**下，该定理和**选择公理**（AC）等价。选择公理是有些反直观的（有兴趣的话可以自行搜索），与它等价的良序定理同样反直观，基本上只能用于理论推导，很难实际应用。

幸运的是，在计算机领域的日常研究中，并不需要使用无所不能的良序定理来“造”出一个良序关系。计算机领域中，输入数据所属的集合总是**可数的**（countable），而<u>可数集合总是可以很轻松地定义良序关系</u>。其中一个典型的例子是所谓的**字典序**（lexicographical order）。

> 实际上，计算机领域的输入数据所属集合总是**有限的**，因为任何硬件设备都存在可承载的数据量上限。但是，在不能用**枚举法**的情况下，通常都会选择将输入集合从有限集扩大为可数集，从而使用针对可数集的**递降法**。

$$
\mathbf{定理（字典序）}\\
\begin{align}
&设{S_n}是一个良序集序列，≺_j是集合Sj上的一个良序关系。\\
&则对于无限笛卡尔积∏S_j=S_1×S_2×S_3×⋯中的两个元素a=(a_1,a_2,a_3,…)和b=(b_1,b_2,b_3,…)，\\
&定义a≺b当且仅当存在某个k，使得a_j=b_j对于1≤j<k恒成立，但a_k ≺_k b_k。\\
&那么≺是∏S_j上的一个良序关系。
\end{align}
$$

上面定义的良序关系，是针对无限长向量的。将它稍微修改一下，就可以用来定义任意长向量。

> 在每个集合$S_j$中增加一个元素$\empty_j$，让这个元素作为$S_j\cup \{\empty_j\}$的最小值。
>
> 对于非无限长的向量$(a_1,a_2,\dots,a_n)$，将其延伸为$(a_1,a_2\dots,a_n,\empty_{n+1},\empty_{n+2},\dots)$，就得到了无限长向量。这个映射是一一对应的，从而可以用无限长向量的字典序去定义任意长向量的字典序。

特别地，由$S_j=\{a,b,\dots,z\}$构成的任意长向量的<u>字典序，就是英文字典中排列单词的顺序</u>。

### 超限的归纳和递降

在定义良序关系之后，就可以使用**超限归纳法**来证明命题。超限归纳法本质上是经典数学归纳法在集合论上的一般形式，可由良序关系的定义直接导出，而无需用到良序定理。
$$
\mathbf{
定理（超限归纳法）}\\
\begin{align}
&令P(x)是一个关于x\in X的命题；f将X映射到关于≺的良序集S。\\
&要证明P(x)对一切x\in X为真，只需要证明：\\
&1. 当f(x_0) =\min S时，P(x_0)为真。\\
&2. 如果对f(y)≺f(x)，P(y)都为真，那么P(x)也为真。
\end{align}
$$

> 上面的表述和经典的超限归纳法表述有所不同。它融合了之前介绍过的“映射”策略。

当$S$取为正整数集$N^+$，良序关系取为熟知的“小于”时，超限归纳法的特例就是经典归纳法。这是最自然的良序关系和良序集。在考研解题过程中，通常都只需要用到这个集合，下面称其为**通常良序集**。

> 尽管解题的时候，通常只会用到通常良序集，但“良序”的思维，仍然广泛存在于计算机领域的各个学科中。

和超限归纳法对应，可以得到一般形式的递降法。
$$
\mathbf{定理（递降法）}\\
\begin{align}
&设算法A(x)的输入数据x\in X；f将X映射到关于≺的良序集S。\\
&要证明A(x)对一切x\in X都可以在有限时间内输出正确结果，只需要证明：\\
&1.	当f(x_0) =\min S时，A(x_0)可以在有限时间内输出正确结果。\\
&2.	对于每个f(x) \ne \min S，A(x)可以在有限时间内将问题化归为有限个A(y_i)，其中f(y_i) ≺f(x)。\\
&且在A(y_i)结果都正确时，得到的A(x)也正确。
\end{align}
$$
递降法和**递归**（recursion）是密不可分的。在递降法中，条件（1）对应了**递归边界**，条件（2）则对应了**递归调用**。边界情况通常对应的是最简单的情况，而递归调用则用来将复杂问题拆解成简单问题。只要您有一定的递归编程的经验，那么递降法是非常容易理解的。

> 递降用于分析算法，而递归用于设计算法，二者思路上相似，只是功能上不同。
>
> 由于<u>递降法用到的计算机思维事实上是递归</u>，下文将不再区分“递降法”和“递归法”。递归（递降）法是《数据结构》学科最为核心的思维方法，在这一章只是用简单的例子介绍它，后面的章节中还会反复出现，并不断增加问题的难度和思维的深度。

下面用几个实际的例子，来说明递降法在正确性检验中的作用。

### 例子：辗转相除法

```c++
// 问题1.2 - 求最大公因数
// 输入：正整数a、b
// 输出：a和b的最大公因数
```

关于这个问题，如果您有一定编程基础，肯定能一眼就知道如何解决。

> 如果您没有编程基础，暂时也不需要记忆这个算法。相关内容的展开介绍放在了《算法设计》学科中。

```c++
// 算法1.2A
int gcd(int a, int b) {
    if (b == 0) {
        return a;
    } else {
        return gcd(b, a % b);
    }
}
```

上面的**算法1.2A**是著名的最大公因数算法：**Euclid辗转相除法**的<u>递归形式</u>。在这个算法中，递归边界是$(a, 0)$，因此可以定义$f(a, b) = \min(a, b)$，将输入数据映射到通常良序集。接着就可以用递降法处理这个问题了。

1. 如果`a<b`，那么通过1次递归，可变换为等价的`gcd(b, a)`。

2. 如果`a>=b>0`，那么由于`b > a%b`对一切正整数`a,b`成立，所以通过1次递归，可变换为`f(.)`更小的`(b, a%b)`。接下来只要证`gcd(a, b) = gcd(b, a%b)`。您可以自己完成这一证明。下面提供了一种比较简单的证法。

   > **证明** 设`a = kb + l`，其中`l = a % b`。
   >
   > 那么，对于`a`和`b`的公因数`d`，设`a = Ad`，`b = Bd`，则`l = (A-kB)d`。因此`d`也是`b`和`l`的公因数。反之，对于`b`和`l`的公因数`d’`，也可推出`d’`也是`a`和`b`的公因数。
   >
   > 因此`a`和`b`的公因数集合，与`b`和`l`的公因数集合相同；它们的最大值显然也相同。

3. 如果`b=0`，到达边界，`gcd(a, 0) = a`正确。（严谨地说，这里需要做确定性验证，即要证明a此时不可能为0。您可以自己完成此处证明。）

如此便完成了Euclid辗转相除法的正确性证明。

### 例子：分治求和

在递降法中允许递归函数调用自身有限次。在**算法1.2A**中，一个`gcd`只会调用一次自身，这种直接将问题转化成更简单问题的思想称为**化归**（transformation）。这一小节展示了一个多次调用自身的例子。

```c++
// 问题1.3 - 数组求和
// 输入：数组A[0:n]
// 输出：A[0]+A[1]+...+A[n-1]的和
```

> 注：`A[0:n]`用来表示大小为`n`的数组`A`。这里借用了Python的写法。
>
> 类似地，`A[l:r]`用来表示数组的一个**切片**（slice），即`A[l]`,` A[l+1]`, ...,` A[r-1]`组成的子数组。

```c++
// 算法1.3A
int f1(int* A, int n) {
    if (n == 0) { return 0; }
    if (n == 1) { return A[0]; }
    return f1(A, n/2) + f1(A + n/2, n - n/2);
}
```

您可以选取`f(A[0:n]) = n/2`，将输入数据的范围从数组映射到通常良序集上。

上述算法的正确性基于加法结合律：<u>n项的和 = 前n/2项的和 + 后(n-n/2)项的和</u>。这种将数据结构（这里是数组）分拆成几个部分，用得到的部分结果“拼出”整体结果的思想称为**分治**（divide-and-conquer）。关于**算法1.3A**的正确性检验过程，您可以仿照**算法1.2A**自己完成。

### 例子：二分法求零点

以上两个例子都是建立在递归上的算法。很多算法可能并不包含递归；对这些算法做有限性检验，不是要排除无穷递归，而是要排除无限循环。下面展示了一个循环的例子。

```c++
// 问题1.4 - 函数零点
// 输入：函数f(x)，区间(l,r)，误差限eps > 0
    /* 输入数据保证f(x)在数学上连续，且f(l)*f(r) < 0 */
// 输出：函数f(x)在区间(l,r)上的一个零点，绝对误差不超过eps
```

对于连续函数`f(x)`来说，由于`f(l)*f(r) < 0`，根据**零点存在定理**，它必定在区间`(l,r)`上存在零点。这个零点可以用二分的方法取得，此算法在高中数学课程中介绍过。

```c++
// 算法1.4A
double solve(function<double(double)> f, double l, double r, double eps) {
    while (r - l > eps) {             // 循环直到满足误差限
        double mid = l + (r - l) / 2; // 每次取(l,r)的中点
        if (f(l) * f(mid) <= 0) {     // 判断零点是否在(l,mid]中
            r = mid;
        } else {                      // 还是在(mid,r)中
            l = mid;
        }
    }
    return l;
}
```

分析循环问题的手段，和分析递归问题是相似的。<u>递归函数的参数，在循环问题里就变成了循环变量</u>。在处理**算法1.4A**的时候，首先找到**循环的停止条件**：`r – l < eps`。这个条件里，`eps`作为输入数据，在循环中是**不变量**，而`l`和`r`是循环中的**变量**。因此，使用递降法的时候可以将`eps`看成常量，而`l`和`r`作为“递归参数”。

定义映射`fs(l,r) = floor((r-l)/eps)`就可以将问题映射到通常良序集，后面的做法和前面几个例子基本相同，您可以自己完成正确性检验。请注意在证明结果正确性时要留意`f(mid) = 0`的情况。

这种<u>“将循环视为递归”然后用递降法处理</u>的方法，等价于将**算法1.4A**改写为以下与其等价的**算法1.4B**。

```c++
// 算法1.4B
double solve_r(function<double(double)> f, double l, double r, double eps) {
    function<double(double, double)> recursion;
    recursion = [f, eps, &recursion](double l, double r) -> double {
        if (r - l < eps) { return l; } // 递归边界
        double mid = l + (r - l) / 2;  // 每次取(l,r)的中点
        if (f(l) * f(mid) <= 0) {      // 判断零点是否在(l,mid]中
            return recursion(l, mid);
        } else {                       // 还是在(mid,r)中
            return recursion(mid, r);
        }
    };
    return recursion(l, r);
}
```

其通用做法是：<u>找到循环的停止条件，然后将条件中出现的、在循环内部被改变的变量视为递归的参数，以此将循环改写为递归</u>。当然，实际解题的时候犯不着费劲改写成递归再分析，用这个思路直接分析循环就可以了。

### 拓展：正确性证明的数学严谨性

在本节的最后，讨论一下和考研无关的内容：关于正确性“严谨证明”的一些争议。

```c++
// 问题1.5 - 角谷猜想
// 输入：正整数x
// 输出：对x反复进行操作：如果是奇数，乘3再加1；如果是偶数，除以2。直到x变为1为止。输出操作序列。

// 算法1.5A
list<int>& f1(int x) {
    static list<int> ans; ans.clear();
	ans.push_back(x);
    do {
        if (x % 2) {
            ans.push_back(x = 3*x+1);
        } else {
            ans.push_back(x = x / 2);
        }
    } while (x != 1);
    return ans;
}
```

这一算法的有限性并未得到证明。如果能找到一个合理的映射和良序关系证明它的有限性，那么也就证明了角谷猜想。然而目前还没有人完成对角谷猜想的严格证明，最接近这一成就的可能是陶哲轩。

> 学术界之外有相当多的人自称证明了角谷猜想，但似乎还未得到学术界的公认。

但有一个存在争议的问题是：未被证明或证伪的数学猜想，在对算法做正确性检验时能否被当成定理使用？一个猜想至今未被证伪，往往是建立在“小数据都不构成反例”的基础上的，比如在**算法1.5A**所使用的`int`范围之内，角谷猜想是绝对正确的。所以事实上，对于任意给定的`int x`，**算法1.5A**都是满足有限性的。

笔者对这个问题的态度是“**从实际需求出发**”。

以**算法1.5A**为例，不考虑`int`的范围限制，它的正确性取决于使用者希望用这个算法达成什么需求。如果使用这个算法的目的是“验证角谷猜想在小范围内成立”，那么无疑这个算法是正确的，因为在小范围内它的有限性是可以保证的。如果使用这个算法的目的是“找到角谷猜想的反例”，那么这个算法就不是正确的，因为仅依靠这个算法自身，无论运行多少时间，都不能证明得到的操作序列是无穷的，所以算法不能保证有限性（除非角谷猜想得到了证明）。

笔者认为，实事求是的态度在计算机学科的学习、备考和研究中都非常重要，有的时候并不需要证明您使用的算法<u>在数学上是正确的</u>，甚至它<u>在数学上就是错的</u>也没有关系，只要能达成您的目的，它就是<u>在工程上是正确的</u>。

