# 算法及其评价

本章是《数据结构》的第一章。这一章将从算法的定义和评价出发，重点介绍在《数据结构》学科中最为重要的思维方法：**递归**（recursion）。这一思维方法的建立为《数据结构》后续知识点的理解和掌握打下了基础。

## 算法的定义和评价

> 我们想事情，做工作，想得对不对，做得好不好，要有一个根本的衡量尺度，这就是人民拥护不拥护，人民赞成不赞成，人民高兴不高兴，人民答应不答应。
>
> ——Chairman Jiang

### 概念和定义的争议

**算法** （algorithm）是计算机领域的核心概念之一。和更加核心的概念“**计算机** （computer）”一样，它没有一个被广泛承认的规范定义。一些教材会把算盘甚至算筹划归“计算机”的范畴，并把手工算法（如尺规作图，甚至按照菜谱烹饪食物）划归“算法”的范畴；而另一些教材仅仅承认现代电子计算机为“计算机”，并把“算法”限定可以在图灵机上通过有限步骤执行的计算方法。

这种**概念和定义的争议**在计算机领域广泛存在，它主要来自以下几个原因（下文中提到的概念，将在后续章节中展开介绍）。

1. <u>为了叙述简便，有些概念会借用一个已经存在的专有名词，从而引发歧义</u>。如“**树** （tree）”这个词在计算机领域就有常用但迥然不同的两个概念。图论中的“树”出现得比较早，但没有人愿意将工程界经常出现的“树”称为“有限有根有序有标号的树”——英文里这些词并不能缩写为“四有树”。
2. <u>不同科学家互相不服气，都认为自己提出的定义更有优越性，从而引发歧义</u>。这个现象的典型例子是“计数时从0开始还是从1开始”。从0开始是有一定数学上的优越性的，可以避免一些公式出现刻意的“+1”余项；但从1开始计数更符合自然习惯。这个问题直接导致在有些问题（如“树的高度”）上，国内不同高校的教材采用的说法互不相同，从而引起一些学生在准备考研时感到困惑。
3. <u>随着计算机领域的快速发展，一些概念的含义会发生变化</u>。如众所周知，“**字节** （byte）”表示8个二进制位；但在远古时代，不同计算机采用的“字节”定义互不相同，有些计算机甚至是十进制的，那个时候一个字节可能表示2个十进制位。
4. <u>受计算机科学家的意识形态影响，同一概念的用词有所不同</u>。如“树上的前驱和后继节点”这一概念，现在普遍使用的词是parent和child；然而思想老旧的人可能还在用father和son，进步主义者则可能会用mother和daughter。
5. <u>计算机领域的大多数成果出自美国，而英语翻译为汉语时，不同译者可能采用不同的译法</u>。如robustness有音译的“**鲁棒性** ”和意译的“**稳健性** ”，hash有音译的“**哈希** ”和意译的“**散列** ”。
6. <u>计算机相关企业为了销售产品或取得投资，存在滥用、炒作部分计算机概念的情况</u>。如“人工智能”“大数据”“云计算”“区块链”等概念是这个现象的重灾区。不过，这些问题概念和考研复习关系不大。

由于以上这种种原因，计算机领域的很多概念都不存在“标准”、“权威”的定义，而是存在争议的。<u>清华大学的考试在争议问题上都会特别标注</u>（如“注：空树的高度认为是-1。”）。其他学校不一定会这样做，因此请务必购买您的目标高校使用的教材；如果教材和您使用的考研辅导书冲突，则需要特别注意。

### 算法定义的四个要素

回到算法的问题上来。在本笔记中，笔者采用“限定词+中心语”的方式定义“**算法** （algorithm）”，而不采用较难理解的数学定义。该定义出自*The Art of Computer Programming Vol 1, 3^rd^ Edition* （Donald E. Knuth，1997）。

> **算法** （algorithm）是<u>对于给定的输入，通过有限的、可行的步骤可以得到确定的、满足预期条件的输出结果的计算方法</u>。

这一定义规定了算法的4个要素：**有限性、可行性、确定性、有输出** 。

值得一提的是，“有输入”这个要素在这个定义中是**可选的**（optional）。这一定义认为形如“找到所有int范围内的素数”就是没有输入的算法。但相对地，“有输出”则是**必需的**，否则算法就失去了存在的意义。

根据上述定义，下面这些都不能成为算法：

1. 计算圆周率的十进制小数形式。（无法在有限步骤内完成）
2. 如果哥德巴赫猜想正确，输出1，否则输出0。（在当前阶段，*不满足可行性*）
3. 输入两个整数a和b，输出a除以b的余数。（*不满足确定性*，因为在b为0的情况下除法没有定义）
4. 读取一个文件。（*没有输出*）

### 在算法设计题中使用定义

*试卷上并不会让您判断一个计算方法是否为算法，因此背诵定义看上去并没有什么用*。这一定义是帮助您完成其他类型的题目的。

在《数据结构》考试中，关于算法最多的是**评价题**，通常有且只有一道的是**设计题**；您在复试的机试中还会面对若干道算法**上机设计题**。理解上述定义，有助于让您在设计算法后“四省吾身”：

1. <u>是否必定能结束</u>？如果您使用了`while (true)`或者`for(;;)`这样的无限循环，或使用了`goto`强制跳转，则存在不满足有限性的潜在风险。
2. <u>是否有语法错误</u>？在初试中，算法设计题的答案通常以伪代码或代码给出。语法错误不一定会被扣分，但**语义歧义**一定会被扣分。
3. <u>是否被正确定义</u>？除以0、空指针、下标越界等问题，都可能是被意外扣分的导火索。在机试中，甚至可能被有针对地设计的测试数据“重点打击”，使您失去大半甚至全部分数。
4. <u>是否有输出结果</u>？对于常见的数据结构维护类题目，数据结构本身就是输出结果，不需要再额外做输出。另一些题目则可能需要输出；尤其在机试时，您可能会忘记某个特殊分支的输出。

### 算法的评价维度

作为一种解决问题的方法，算法的评价是多尺度的，它们构成了算法题的另一种题型。即使是在算法设计题中，也经常有“对设计的算法进行评价”的附加要求。

1. **正确性**。**正确性检验**通常分为两个方面：**有限性检验**和**结果正确性检验** 。

   1. **有限性检验** 。即判定带有无限循环或强制跳转的算法是否必定能终止。没有无限循环或强制跳转的情况，有限性是默认的。
   
   2. **结果正确性检验** 。即验证输出的结果满足算法的需求。在算法有确定的正确结果时，这一检验是“非黑即白”的；而在算法没有确定的正确结果时，可能需要专用的检验程序甚至人工打分（比如较早的象棋AI，往往是以高手对一些局面的形势打分作为基础训练数据的）。
   
      *作为四要素中的另外两项：**可行性**是否成立往往一眼便知；而**确定性**如果不是一眼便知，则往能蕴含在其他两项检验当中。证明可以<u>通过有限步得到正确结果</u>，实际上也就证明了<u>在此期间不存在未定义行为</u>。*
   
2. **效率** 。评价算法效率的标准可以简单概括为“<u>多、快、好、省</u>”。在《数据结构》学科中通常只研究“快”和“省”这2个方面，到《网络原理》部分再展开来讨论全部的4个方面。

   1. **时间效率（快）** 。在计算机上运行算法一定会消耗时间，时间效率高的算法消耗的时间比较短。

   2. **空间效率（省）** 。在计算机上运行算法一定会消耗空间（硬件资源），空间效率高的算法消耗的硬件资源比较少。

      然而，在不同的计算机、不同的操作系统、不同的编程语言实现下，同一算法消耗的时间和空间可能大相径庭。为了抵消这些变量对算法效率评价的干扰作用，在《数据结构》这门学科里进行算法评价时，往往不那么注重真实的时间、空间消耗，而倾向于做**复杂度分析** 。关于复杂度的讨论参见后文。

3. **稳健性** （robustness，又译健壮性、鲁棒性；在看到英文之前，笔者曾一度认为“鲁棒性”这个词来源于山东大汉身体棒的地域刻板印象……）。即算法面对意料之外的输入的能力。
4. **可重用性** 。即算法是否能很方便地用于设计目的之外的其他场合。

在上述4个评价尺度中，<u>正确性和效率是《数据结构》学科研究的主要内容，算法评价题也总是围绕正确性检验和复杂度分析命题</u>；这两个问题留到下一节展开讨论。而稳健性和可重用性，则在课程设置上属于《软件工程》讨论的内容；作为考研复习笔记不再详述。

### 算法的具体实现形式：程序

由于后两个问题更偏向工程而非理论，这两个评价尺度更多地是和**算法的具体实现形式**而不是**算法本身**高度相关。*初学者很容易将算法和算法的具体实现形式混淆*。

算法的具体实现形式是依赖于具体的计算机、操作系统、编程语言的具体的**程序** （program）。对程序的分析和对算法的分析有着基础上的差异，下面的例子中可以看出这一点。

```c++
// 问题1.1 - 从1加到n
// 输入：正整数n
// 输出：1 + 2 + ... + n的和
```

Gauss小时候就得到了这个问题的一般公式，您很容易得到下面的算法。

```c++
// 算法1.1
// 1. 输入正整数n
// 2. 计算A = n*(n+1)/2
// 3. 输出结果A
```

根据这一算法，您可以编写出下面的程序：

```c++
// 算法1.1A
int f1(int n) {
    return n*(n+1)/2;
}
```

由于这个**算法**的正确性十分显然，以至于您或许觉得这个**程序**也毫无问题。直到您看到了另一个程序：

```c++
// 算法1.1B
int f2(int n) {
    return n % 2 == 1 ? (n+1)/2*n : n/2*(n+1);
}
```

您大概立刻意识到了**算法1.1A**存在的问题：对于某一区间内的`n`，`n*(n+1)/2`的和不会超过`max_int`的值，但`n*(n+1)`会超过这个值。比如，当`n`取`50000`的时候，**算法1.1B**能够输出正确的结果，而**算法1.1A**则会因为数据溢出而输出一个负数。您可以很容易算出这个“**算法1.1B**结果正确而**算法1.1A**不正确”的区间。

但**算法1.1B**也很难称之为无可挑剔。因为如果`n`更大一些，比如取`100000`，它也无法输出一个正确的值。

所以是**算法1.1**不正确吗？显然不是，Gauss已经证明了它的正确性。**算法1.1A**和**算法1.1B**不能对所有输入的`int`型数据得到正确的结果，这是因为`int`有数据范围限制。但是，世界上并不存在无数据范围限制的计算机（因为一台计算机上的硬件资源必定是有限的），所以如果溢出算是一种“错误”，就不会存在“正确”的算法了。

那么，是否有必要为输入的数据`n`增加一个范围限制，来保证**算法1.1**的正确？事实上这个范围限制很难设计。

其原因在于，<u>算法必须是独立于计算机的</u>。现在`max_int`当然是`2147483647`，但是在古代的16位计算机上，这个值有可能是`65536`（ANSI C标准只规定了`int`至少16位）。此外，在C++里整型数据有显式的上界`max_int`，但在另一些支持`BigInteger`的语言（如Java）中，整数是没有显式的上界的，其实际上界和计算机的空闲存储空间相关，这在每一台计算机上几乎都是不一样的。

如果一定要评价**算法1.1**的不足，只能说它在**稳健性**上有所欠缺：<u>现代计算机处理溢出数据是截断的</u>，所以当`n*(n+1)/2`的超出`int`范围时，它可能会输出一个负数。

为了提高稳健性，更好的算法可能会让`n*(n+1)/2`的和超出`int`范围时输出`max_int`，以表示“这个结果很大”。事实上，有些古代计算机在设计时就让“超出`int`范围时，整形成`max_int`”；但这样设计硬件或指令集是得不偿失的，在《组成原理》中您会看到这一点。

在《数据结构》这门学科中，您可以认为**算法1.1**是一个毫无疑问的好算法。它已有Gauss证明是正确的，并且在时间和空间上都效率很高。